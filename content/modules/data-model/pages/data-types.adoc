= Интерфейс Datatype

Каждый атрибут сущности, не являющийся ссылкой, связан с реализацией интерфейса `Datatype`. Этот интерфейс определяет методы конвертации значений атрибутов в строки и из строк (форматирование и парсинг) при отображении сущностей в xref:backoffice-ui:index.adoc[] и сериализации в xref:rest:index.adoc[].

Фреймворк предоставляет набор реализаций `Datatype`, соответствующих стандартным типам данных xref:data-model:entities.adoc#attributes[атрибутов сущностей].

NOTE: В данном руководстве термин _datatype_, написанный строчными буквами, используется для обозначения реализаций интерфейса `Datatype`.

[[localized-format-strings]]
== Локализованные строки форматов

Многие стандартные datatype используют набор строк форматов, определяемых в xref:localization:message-bundles.adoc[пакете сообщений]. Это дает возможность форматирования и парсинга, зависящих от текущего языка пользователя. Набор строк форматов по умолчанию, определяемый фреймворком, выглядит следующим образом:

[source,properties]
----
# Date/time formats
dateFormat = dd/MM/yyyy
dateTimeFormat = dd/MM/yyyy HH:mm
offsetDateTimeFormat = dd/MM/yyyy HH:mm Z
timeFormat = HH:mm
offsetTimeFormat = HH:mm Z

# Number formats
integerFormat = #,##0
doubleFormat = #,##0.###
decimalFormat = #,##0.##

# Number separators
numberDecimalSeparator = .
numberGroupingSeparator = ,

# Booleans
trueString = True
falseString = False
----

Чтобы использовать собственные строки формата, добавьте соответствующие сообщения в пакет сообщений вашего приложения. Например, чтобы использовать формат даты Соединенных Штатов с английской локалью, добавьте следующие строки в файл `messages_en.properties`:

.messages_en.properties
[source,properties]
----
include::example$/ex1/src/main/resources/datamodel/ex1/messages.properties[tags=format-strings]
----

Кроме того, вы можете определить отдельную локаль `en_US` и задать строки формата данных в файле `messages_en_us.properties`.

TIP: Вы можете настроить строки форматов данных с помощью Studio: откройте вкладку *Locales* в окне *Project Properties* и поставьте флажок *Show data format strings*.

[[custom-format]]
== Специализированные форматирование и парсинг

Вы можете настроить форматирование и парсинг значений для определенных атрибутов сущности, создав свой собственный datatype и назначив его этим атрибутам.

В качестве примера представим, что в вашем приложении есть атрибуты сущностей, хранящие годы в виде целых чисел. Пользователи должны иметь возможность просматривать и редактировать годы, причем если пользователь вводит только две цифры, приложение должно преобразовать их в год между 2000 и 2100. В противном случае все введенное число считается годом.

Во-первых, создайте класс реализации `Datatype` и аннотируйте его `@DatatypeDef`:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/datamodel/ex1/datatype/YearDatatype.java[tags=datatype]
----

<1> Уникальный идентификатор datatype.
<2> Класс Java, обрабатываемый данным datatype.
<3> Форматирование без учета локали текущего пользователя. Этот метод вызывается для преобразования на системном уровне.
<4> Форматирование с учетом локали текущего пользователя. Этот метод вызывается в Backoffice UI.
<5> Парсинг без учета локали текущего пользователя. Этот метод вызывается для преобразования на системном уровне.
<6> Парсинг с учетом локали текущего пользователя. Этот метод вызывается в Backoffice UI.

После создания реализации `Datatype` вы можете указать ее для атрибута сущности, используя аннотацию xref:entities.adoc#property-datatype[@PropertyDatatype]:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/datamodel/ex1/entity/Model.java[tags=datatype]
----

[[custom-type]]
== Поддержка произвольных классов Java

Вы можете использовать произвольный класс Java в качестве типа атрибутов сущности.

Предположим, что вы создали класс Java, представляющий географическую координату:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/datamodel/ex1/entity/GeoPoint.java[tags=datatype]
----

Теперь вы хотите использовать этот класс в качестве типа атрибута сущности JPA.

Во-первых, создайте конвертер JPA для этого класса:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/datamodel/ex1/datatype/GeoPointConverter.java[tags=datatype]
----

<1> С `autoApply = true` вам не нужно указывать конвертер для каждого атрибута. Конвертер будет применен ко всем атрибутам соответствующего типа.

Затем создайте класс реализации `Datatype` для `GeoPoint` и аннотируйте его `@DatatypeDef`:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/datamodel/ex1/datatype/GeoPointDatatype.java[tags=datatype]
----

<1> Уникальный идентификатор datatype.
<2> Класс Java, обрабатываемый данным datatype.
<3> `defaultForClass = true` означает, что datatype будет автоматически применен ко всем атрибутам сущности типа `GeoPoint`.
<4> Используя аннотацию `@Ddl`, вы можете указать, какой тип SQL следует использовать для атрибутов сущности. Studio учитывает эту аннотацию при создании скриптов xref:db-migration.adoc[миграции базы данных].
<5> Форматирование без учета локали текущего пользователя. Этот метод вызывается для преобразования на системном уровне.
<6> Форматирование с учетом локали текущего пользователя. Этот метод вызывается в Backoffice UI.
<7> Парсинг без учета локали текущего пользователя. Этот метод вызывается для преобразования на системном уровне.
<8> Парсинг с учетом локали текущего пользователя. Этот метод вызывается в Backoffice UI.

После этого, когда вы определите атрибут сущности типа `GeoPoint`, фреймворк будет использовать созданные вами конвертер JPA и datatype:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/datamodel/ex1/entity/Address.java[tags=datatype]
----
