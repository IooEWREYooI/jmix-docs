= Интерфейс Datatype

Каждый атрибут сущности, не являющийся ссылкой, связан с реализацией интерфейса `Datatype`. Этот интерфейс определяет методы конвертации значений атрибутов в строки и из строк (форматирование и парсинг) при отображении сущностей в xref:ui:index.adoc[] и сериализации в xref:rest:index.adoc[].

Фреймворк предоставляет набор реализаций `Datatype`, соответствующих стандартным типам данных xref:data-model:entities.adoc#attributes[атрибутов сущностей].

NOTE: В данном руководстве термин _datatype_, написанный строчными буквами, используется для обозначения реализаций интерфейса `Datatype`.

[[localized-format-strings]]
== Локализованные строки форматов

Многие стандартные datatype используют набор строк форматов, определяемых в xref:localization:message-bundles.adoc[пакете сообщений]. Это дает возможность форматирования и парсинга, зависящих от текущего языка пользователя. Набор строк форматов по умолчанию, определяемый фреймворком, выглядит следующим образом:

[source,properties]
----
# Date/time formats
dateFormat = dd/MM/yyyy
dateTimeFormat = dd/MM/yyyy HH:mm
offsetDateTimeFormat = dd/MM/yyyy HH:mm Z
timeFormat = HH:mm
offsetTimeFormat = HH:mm Z

# Number formats
integerFormat = #,##0
doubleFormat = #,##0.###
decimalFormat = #,##0.##

# Number separators
numberDecimalSeparator = .
numberGroupingSeparator = ,

# Booleans
trueString = True
falseString = False
----

Чтобы использовать собственные строки формата, добавьте соответствующие сообщения в пакет сообщений вашего приложения. Например, чтобы использовать формат даты Соединенных Штатов с английской локалью, добавьте следующие строки в файл `messages_en.properties`:

.messages_en.properties
[source,properties]
----
include::example$/ex1/src/main/resources/datamodel/ex1/messages.properties[tags=format-strings]
----

Кроме того, вы можете определить отдельную локаль `en_US` и задать строки формата данных в файле `messages_en_us.properties`.

TIP: Вы можете настроить строки форматов данных с помощью Studio: откройте вкладку *Locales* в окне *Project Properties* и поставьте флажок *Show data format strings*.

[[custom-format]]
== Специализированные форматирование и парсинг

Вы можете настроить форматирование и парсинг значений для определенных атрибутов сущности, создав свой собственный datatype и назначив его этим атрибутам.

В качестве примера представим, что в вашем приложении есть атрибуты сущностей, хранящие годы в виде целых чисел. Пользователи должны иметь возможность просматривать и редактировать годы, причем если пользователь вводит только две цифры, приложение должно преобразовать их в год между 2000 и 2100. В противном случае все введенное число считается годом.

Во-первых, создайте класс реализации `Datatype` и аннотируйте его `@DatatypeDef`:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/datamodel/ex1/datatype/YearDatatype.java[tags=datatype]
----

<1> Уникальный идентификатор datatype.
<2> Класс Java, обрабатываемый данным datatype.
<3> Форматирование без учета локали текущего пользователя. Этот метод вызывается для преобразования на системном уровне.
<4> Форматирование с учетом локали текущего пользователя. Этот метод вызывается в Backoffice UI.
<5> Парсинг без учета локали текущего пользователя. Этот метод вызывается для преобразования на системном уровне.
<6> Парсинг с учетом локали текущего пользователя. Этот метод вызывается в Backoffice UI.

После создания реализации `Datatype` вы можете указать ее для атрибута сущности, используя аннотацию xref:entities.adoc#property-datatype[@PropertyDatatype]:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/datamodel/ex1/entity/Model.java[tags=datatype]
----

[NOTE]
====
Бины, например xref:localization:message-bundles.adoc#using-messages-in-java[Messages], нельзя напрямую инжектировать в классы datatype используя `@Autowired`, так как экземпляры datatype инициализируются в самом начале процесса запуска приложения и такая инжекция может вызвать циклическую зависимость.

Вместо этого, инжектируйте `ApplicationContext` и используйте его методы `getBean()` для получения требуемых бинов.
====

[[custom-type]]
== Поддержка произвольных классов Java

Вы можете использовать произвольный класс Java в качестве типа атрибутов сущности.

Предположим, что вы создали класс Java, представляющий географическую координату:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/datamodel/ex1/entity/GeoPoint.java[tags=datatype]
----

Теперь вы хотите использовать этот класс в качестве типа атрибута сущности JPA.

Во-первых, создайте конвертер JPA для этого класса:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/datamodel/ex1/datatype/GeoPointConverter.java[tags=datatype]
----

<1> С `autoApply = true` вам не нужно указывать конвертер для каждого атрибута. Конвертер будет применен ко всем атрибутам соответствующего типа.

Затем создайте класс реализации `Datatype` для `GeoPoint` и аннотируйте его `@DatatypeDef`:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/datamodel/ex1/datatype/GeoPointDatatype.java[tags=datatype]
----

<1> Уникальный идентификатор datatype.
<2> Класс Java, обрабатываемый данным datatype.
<3> `defaultForClass = true` означает, что datatype будет автоматически применен ко всем атрибутам сущности типа `GeoPoint`.
<4> Используя аннотацию `@Ddl`, вы можете указать, какой тип SQL следует использовать для атрибутов сущности. Studio учитывает эту аннотацию при создании скриптов xref:db-migration.adoc[миграции базы данных].
<5> Форматирование без учета локали текущего пользователя. Этот метод вызывается для преобразования на системном уровне.
<6> Форматирование с учетом локали текущего пользователя. Этот метод вызывается в Backoffice UI.
<7> Парсинг без учета локали текущего пользователя. Этот метод вызывается для преобразования на системном уровне.
<8> Парсинг с учетом локали текущего пользователя. Этот метод вызывается в Backoffice UI.

После этого, когда вы определите атрибут сущности типа `GeoPoint`, фреймворк будет использовать созданные вами конвертер JPA и datatype:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/datamodel/ex1/entity/Address.java[tags=datatype]
----

[[conversion-error]]
== Conversion Error Messages

When a datatype is used by a UI component to parse string input, it may produce parsing exceptions. The UI component handles the exception and shows a xref:ui:vcl/components/text-field.adoc#data-type-conversion[user-friendly message]. These messages are located in the message bundle of the framework with the `databinding.conversion.error.<datatype-id>` keys. For example:

[source,properties]
----
databinding.conversion.error.boolean=Must be Boolean
----

For the whole list of messages, see https://github.com/jmix-framework/jmix/blob/master/jmix-ui/ui/src/main/resources/io/jmix/ui/messages.properties[messages.properties^] for the branch corresponding to Jmix version used in your project.

If a message for a datatype does not exist, the following generic message is used:

[source,properties]
----
databinding.conversion.error.defaultMessage=Wrong format
----

You can override the error messages in your project just by providing messages with the same keys. Also, provide error messages for your custom datatypes, for example:

[source,properties,indent=0]
----
include::example$/ex1/src/main/resources/datamodel/ex1/messages.properties[tags=conversion-error]
----

[[using-datatype]]
== Using Datatype Directly

Most of the time `Datatype` implementations are used internally by the framework to provide formatting and parsing of entity attributes. But sometimes you may need to use a datatype directly in your code.

Consider that you have a `TextField` component not bound to any entity attribute:

[source,xml,indent=0]
----
include::example$/ex1/src/main/resources/datamodel/ex1/screen/order/order-browse.xml[tags=datatype]
----

Then, if you want to enter decimal values in this component, you can assign a datatype to it in the screen controller by obtaining the datatype from the `DatatypeRegistry` bean:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/datamodel/ex1/screen/order/OrderBrowse.java[tags=datatype]
----

TIP: In fact, you can assign a datatype to a text field more easily in XML, see xref:ui:vcl/components/text-field.adoc#data-type[datatype] attribute of the component.

If you need to get a datatype of an entity attribute, you can do it through xref:metadata.adoc[metadata]. Below is a rather synthetic example of parsing a decimal value using a datatype corresponding to an entity property:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/datamodel/ex1/bean/CustomerService.java[tags=get-datatype]
----