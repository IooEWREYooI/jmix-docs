= 数据类型

每个非引用类型的实体属性都与一个 `Datatype` 接口的实现相关联。 此接口定义了在 xref:ui:index.adoc[] 中显示实体和在 xref:rest:index.adoc[] 中序列化时将属性值与字符串转换（格式化和解析）的方法。

本框架提供了一组对应于 xref:data-model:entities.adoc#attributes[实体属性] 的标准数据类型 的 `Datatype` 实现。

NOTE: 我们使用全部小写的 _datatype_ 来指代 `Datatype` 接口的实现。

借助 xref:ui:vcl/xml.adoc#datatype[数据类型] 属性，可以在界面描述文件中以声明的方式设置 UI 组件的数据类型。

要通过 Java 代码获取数据类型，需要将 `DatatypeRegistry` bean 注入控制器，然后使用它来获取 `Datatype` 实例，例如：

[source,java]
----
@Autowired
private DatatypeRegistry datatypeRegistry;

@Install(to = "customersGrid.discount", subject = "columnGenerator")
private Component customersGridDiscountColumnGenerator(DataGrid.ColumnGeneratorEvent<Customer> columnGeneratorEvent) {
    TextField discountField = uiComponents.create(TextField.NAME);
    Datatype datatype = datatypeRegistry.get(BigDecimal.class);
    discountField.setDatatype(datatype);
    return discountField;
}
----

[[localized-format-strings]]
== 字符串本地化

Many standard datatypes use a set of format strings defined in the xref:localization:message-bundles.adoc[message bundle]. It enables formatting and parsing dependent on the current user locale. The default set of format strings defined in the framework is the following:
许多标准数据类型使用 xref:localization:message-bundles.adoc[消息包] 中定义的字符串格式。 它可以根据当前用户的区域设置进行格式化和解析。 框架中默认的字符串格式如下：

[source,properties]
----
# Date/time formats
dateFormat = dd/MM/yyyy
dateTimeFormat = dd/MM/yyyy HH:mm
offsetDateTimeFormat = dd/MM/yyyy HH:mm Z
timeFormat = HH:mm
offsetTimeFormat = HH:mm Z

# Number formats
integerFormat = #,##0
doubleFormat = #,##0.###
decimalFormat = #,##0.##

# Number separators
numberDecimalSeparator = .
numberGroupingSeparator = ,

# Booleans
trueString = True
falseString = False
----

要提供您自己的字符串格式，需要将相应的消息添加到应用程序的消息包中。 例如，要为英语区域设置美国日期格式，将以下行添加到您的 `messages_en.properties` 文件中：

.messages_en.properties
[source,properties]
----
include::example$/ex1/src/main/resources/datamodel/ex1/messages.properties[tags=format-strings]
----

或者，定义一个单独的 `en_US` 区域环境并在 `messages_en_US.properties` 文件中设置字符串格式。

TIP: 您可以使用 Studio 配置字符串格式：打开 *Project Properties* 窗口的 *Locales* 选项卡，然后勾选 *Show data format strings* 复选框。

[[custom-format]]
== 定制格式和解析

您可以将自己创建的数据类型分配给属性来实现自定义特定实体属性值的格式和解析。

假设您的应用程序中的某些实体属性存储日历年，由 integer 表示。 用户应该能够查看和编辑年份，如果用户只输入两位数字，应用程序应将其转换为 2000 到 2100 之间的年份。否则，将输入的整个数字视为年份。

首先，实现 `Datatype` 接口并用 `@DatatypeDef` 标注：

[source,java,indent=0]
----
include::example$/ex1/src/main/java/datamodel/ex1/datatype/YearDatatype.java[tags=datatype]
----

<1> 数据类型的唯一标识。
<2> 该数据类型处理的 Java 类。
<3> 默认的格式化（没有区域设置时）。 进行系统级转换时使用此方法。
<4> 基于区域设置的格式化。 在 UI 中时使用此方法。
<5> 默认解析方法。 进行系统级转换时使用此方法。
<6> 基于区域设置的解析。 在 UI 中时使用此方法。

创建 `Datatype` 实现后，您可以使用 xref:entities.adoc#property-datatype[@PropertyDatatype] 注解指定给实体属性：

[source,java,indent=0]
----
include::example$/ex1/src/main/java/datamodel/ex1/entity/Model.java[tags=datatype]
----

[NOTE]
====
You cannot inject other beans like xref:localization:message-bundles.adoc#using-messages-in-java[Messages] directly into the datatype class using `@Autowired`, because datatypes are initialized early in the startup process and such injection will cause a circular dependency.

Instead, inject `ApplicationContext` and use its `getBean()` methods to locate required beans when needed.
您不能使用 `@Autowired` 将其他 beans（比如 xref:localization:message-bundles.adoc#using-messages-in-java[Messages]） 直接注入到数据类型类中，因为数据类型在启动过程的早期就已初始化，而且此类注入将导致循环依赖。

如果需要的话，注入 `ApplicationContext` 并使用它的 `getBean()` 方法来获取所需的 bean。
====

[[custom-type]]
== 定制Java类

您可以使用定制 Java 类作为实体属性的类型。

假设您创建了一个表示地理坐标的 Java 类：

[source,java,indent=0]
----
include::example$/ex1/src/main/java/datamodel/ex1/entity/GeoPoint.java[tags=datatype]
----

现在您想将它用作 JPA 实体属性的类型。

首先，为您的类创建一个 JPA 转换器：

[source,java,indent=0]
----
include::example$/ex1/src/main/java/datamodel/ex1/datatype/GeoPointConverter.java[tags=datatype]
----

<1> 使用 `autoApply = true` 以后，您不需要在每个属性上都指定转换器。 转换器将应用于对应类型的所有属性。

然后为 `GeoPoint` 实现 `Datatype` 接口，并用 `@DatatypeDef` 标注：
[source,java,indent=0]
----
include::example$/ex1/src/main/java/datamodel/ex1/datatype/GeoPointDatatype.java[tags=datatype]
----

<1> 数据类型的唯一标。
<2> 该数据类型所处理的 Java 类。
<3> `defaultForClass = true` 表示数据类型将自动应用于所有 `GeoPoint` 类型的实体属性。
<4> 使用`@Ddl`注解，你可以指定实体属性对应的 SQL 类型。 Studio 在生成 xref:db-migration.adoc[数据库变更] 脚本时会考虑此注解。
<5> 默认的格式化（没有区域设置时）。 进行系统级转换时使用此方法。
<6> 基于区域设置的格式化。 在 UI 中时使用此方法。
<7> 默认解析方法。 进行系统级转换时使用此方法。
<8> 基于区域设置的解析。 在 UI 中时使用此方法。

之后，当您定义 `GeoPoint` 类型的实体属性时，框架将使用您定制的 JPA 转换器和数据类型：
[source,java,indent=0]
----
include::example$/ex1/src/main/java/datamodel/ex1/entity/Address.java[tags=datatype]
----
