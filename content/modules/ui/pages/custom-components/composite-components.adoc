= Композитные компоненты

++++
<div class="backoffice-ui-live-demo-container">
    <a href="https://demo.jmix.io/sampler/#main/sample?id=composite-component" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

Композитный компонент — это компонент, состоящий из других компонентов. Как и xref:using-fragments.adoc[фрагменты экранов], композитные  компоненты позволяют переиспользовать некоторую компоновку и логику презентации. Мы рекомендуем использовать композитные компоненты в следующих случаях:

* Функциональность компонента может быть реализована комбинацией существующих xref:vcl.adoc[визуальных компонентов]. Если вам требуются какие-либо нестандартные возможности, используйте xref:custom-components/js-component.adoc[Универсальный JavaScriptComponent].
* Компонент относительно прост и не загружает/сохраняет данные самостоятельно. В противном случае рассмотрите возможность создания фрагмента экранов.

Класс композитного компонента должен расширять базовый класс `CompositeComponent`. Композитный компонент должен иметь единственный компонент в качестве корня внутреннего дерева компонентов. Корневой компонент можно получить методом `CompositeComponent.getComposition()`.

Внутренние компоненты удобно определять декларативно в XML. В этом случае класс компонента должен иметь аннотацию `@CompositeDescriptor`, задающую путь к файлу дескриптора. Если значение аннотации не начинается с символа `/`, файл дескриптора загружается из файла, находящегося в том же пакете, что и класс компонента.

Альтернативой является создание дерева внутренних компонентов программно, в обработчике события `CreateEvent`.

`CreateEvent` посылается фреймворком, когда он заканчивает инициализацию компонента. В этот момент, если компонент использует XML-дескриптор, он загружен, и метод `getComposition()` возвращает корневой внутренний компонент. Данное событие можно использовать как для дополнительной инициализации компонента, так и для создания внутренних компонентов без XML.

Ниже описывается пошаговое создание компонента `Stepper`, предназначенного для редактирования целочисленного значения в поле ввода нажатием на кнопки вверх/вниз рядом с полем.

[[component-layout-descriptor]]
== Создание дескриптора компоновки компонента

Создайте XML-дескриптор с компоновкой компонента:

[source,xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/components/stepper/stepper-component.xml[]
----

<1> XSD определяет содержимое дескриптора компонента.
<2> Один корневой компонент.
<3> Любое количество вложенных компонентов.
<4> Укажите имена стилей, которые будут определены позже в разделе <<styling, Собственный стиль>>. Помимо пользовательских стилей, определенных в проекте, используются следующие предопределенные стили: xref:vcl/containers/css-layout.adoc#v-component-group[v-component-group], `icon-only`.

[[component-implementation-class]]
== Создание класса реализации компонента

Создайте класс реализации компонента в том же пакете:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/components/stepper/StepperField.java[tags=component-start;component-end]
----

<1>  Аннотация `@CompositeDescriptor` указывает путь к дескриптору компоновки компонента, который находится в том же пакете, что и класс.
<2> Класс компонента наследуется от `CompositeComponent`, параметризованного типом корневого компонента.
<3> Компонент `StepperField` реализует интерфейс `Field<Integer>`, ак как он предназначен для отображения и редактирования целочисленных значений.
<4> Набор интерфейсов с дефолтными методами для реализации стандартной функциональности компонента пользовательского интерфейса.
<5> Имя компонента, используемое для регистрации этого компонента для распознавания фреймворком.
<6> Поля, содержащие ссылки на внутренние компоненты.
<7> Свойство компонента, задающее значение изменения при нажатии на кнопки вверх/вниз. Свойство имеет публичные getter/setter методы и может быть назначено в XML экрана.
<8> Инициализация компонента производится в слушателе события `CreateEvent`.

Вы можете автоматически связать бины Spring с классом реализации компонента, например:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/components/stepper/StepperField.java[tags=set-message-tools]
----

[[component-loader]]
== Создание загрузчика компонентов

Создайте загрузчик компонента для того, чтобы компонент можно было использовать в XML-дескрипторах экранов:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/components/stepper/StepperFieldLoader.java[]
----

<1> Класс загрузчика должен наследоваться от `AbstractComponentLoader`, параметризованного классом компонента. В нашем случае, так как компонент реализует `Field`, необходимо воспользоваться более специфичным базовым классом `AbstractFieldLoader`.
<2> Создание компонента по его имени.
<3> Загрузка свойства `step` из XML, если оно указано.

[[component-registration]]
== Регистрация компонента

Чтобы зарегистрировать компонент и его загрузчик во фреймворке, создайте класс конфигурации Spring с аннотацией `@Configuration` для добавления или переопределения компонентов UI:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/ComponentConfiguration.java[tags=component-configuration;stepper-field-registration]
----

<1> Определите объявление бина `ComponentRegistration`.

Приведенный выше код регистрирует новый компонент `StepperField` с:

* *именем*: `StepperField.NAME`;
* *классом*: `StepperField.class`;
* *именем XML-тега*: `StepperField.NAME`;
* *классом загрузчика*: `StepperFieldLoader.class`;

Теперь фреймворк сможет распознать новый компонент в XML-дескрипторах экранов приложения.

[NOTE]
====
Используйте аннотацию Spring `@Order` для обработки порядка регистрации компонентов. Порядок предоставления бинов `ComponentRegistration` очень важен, потому что компоненты с одинаковыми именами будут отфильтрованы, если имеют более низкий приоритет. Например, рассмотрим две конфигурации:

* конфигурация из некого дополнения:
+
[source,java,indent=0]
----
@Bean
@Order(200)
protected ComponentRegistration newButton() {
    return ComponentRegistrationBuilder.create(Chart.NAME)
            .withComponentClass(WebChart.class)
            .withComponentLoaderClass(ChartLoader.class)
            .build();
}
----
* конфигурация проекта с компонентом, переопределяющим компонент `WebChart`:
+
[source,java,indent=0]
----
@Bean
@Order(100)
protected ComponentRegistration newButton() {
    return ComponentRegistrationBuilder.create(Chart.NAME)
            .withComponentClass(MyWebChart.class)
            .withComponentLoaderClass(ChartLoader.class)
            .build();
}
----

В этом случае компонент из дополнения имеет более низкий приоритет и не будет зарегистрирован. Это означает, что вам нужно предоставить полную информацию о компоненте `MyWebChart`: имя, тег (если он не совпадает с именем), класс компонента и класс загрузчика.
====

[[component-xsd]]
== Создание XSD компонента

XSD требуется для использования компонента в XML-дескрипторах экранов.

Создайте файл `app-ui-component.xsd` в том же каталоге, что и <<component-layout-descriptor,дескриптор компоновки компонента>>:

[source,xsd,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/components/stepper/app-ui-components.xsd[]
----

<1> Наследование всех базовых свойств поля.
<2> Определение атрибута для свойства `step`.

[[styling]]
== Собственный стиль

Теперь давайте добавим собственные стили, указанные ранее в атрибуте xref:vcl/xml.adoc#stylename[stylename], для улучшения визуального представления компонента.

Создайте xref:themes/custom_theme.adoc[собственную тему] и добавьте несколько стилей CSS:

[source, css,indent=0]
----
include::example$/ex1/src/main/themes/helium-ext/helium-ext.scss[tags=helium-start;stepper-field;helium-end]
----

[[using-composite-component]]
== Использование композитного компонента

Пример использования созданного компонента в экране приложения:

[source,xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/component/compositecomponent/composite-component-screen.xml[]
----

<1> Namespace ссылается на XSD компонента.
<2> Композитный компонент, связанный с атрибутом `rating` сущности.

Перезапустите сервер приложения и откройте экран. Форма с созданным композитным компонентом `Stepper` должна выглядеть следующим образом:

image::vcl/components/composite-component.png[align="center"]