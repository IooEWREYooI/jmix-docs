= Создание GWT-компонента

[[creating-custom-widgetset]]
== Создание пользовательского набора виджетов

Фреймворк Jmix предоставляет готовый набор виджетов в артефакте `jmix-ui-widgets-compiled`.

Для создания пользовательского набора виджетов в проекте необходимо:

. Удалить зависимость `implementation 'io.jmix.ui:jmix-ui-widgets-compiled'`.
. Добавить зависимости к вашему `build.gradle`:
+
[source,gradle,indent=0]
----
include::example$/ex1/build.gradle[tags=widgets-dependency]
----
<1> Требуется только для разработки пользовательских клиентских компонентов.
+

[[compile-widgets]]
. Добавьте задачу `compileWidgets` (измените пути в соответствии с базовым пакетом вашего приложения):
+
[source,gradle,indent=0]
----
include::example$/ex1/build.gradle[tags=compile-widgets]
----
+
[NOTE]
====
Параметры `excludePaths` и `includePaths` для задачи `compileWidgets` полезны, если вы не хотите компилировать набор виджетов в случае, например, изменения какого-либо экрана.

Параметр `excludePaths` используется для исключения некоторых путей или файлов из компиляции набора виджетов. См. пример:

[source,gradle,indent=0]
----
compileWidgets {
    generate 'com.company.demo.widgets.CustomWidgetSet'
    excludePaths('**/com/company/demo/**')
}
----

Теперь изменения в пакете `com.company.demo` не вызывают компиляцию набора виджетов.

Параметр `includePaths` используется для включения некоторых путей или файлов в компиляцию набора виджетов.

См. пример:
[source,gradle,indent=0]
----
compileWidgets {
    generate 'com.company.demo.widgets.CustomWidgetSet'
    includePaths('**/io/jmix/**/widget/**', '**/com/company/demo/widgets/**')
}
----

Теперь изменения в пакете `com.company.demo.widgets` и в любом пакете `widget` (включая подпакеты) внутри пакета `io.jmix` вызывают компиляцию набора виджетов. Другие изменения, например, в контроллерах экрана или XML-дескрипторах, не вызывают компиляции. Если наблюдается неожиданная перекомпиляция, проверьте причину (выполните `compileWidgets` с параметром `--info`).

Параметры `excludePaths` и `includePaths` принимают список шаблонов строк.

Шаблоны могут включать:

* `*` для соответствия любому количеству символов.
* `?` для соответствия любому одиночному символу.
* `**` для соответствия любому количеству каталогов или файлов.

`'/'` или `'\'` могут использоваться для разделения каталогов в шаблоне.

Например, `+includePaths('**/com/company/demo/widgets/**')+` включает все файлы в каталоге `com/company/demo/widgets`, включая подкаталоги.

См. дополнительную информацию по адресу https://docs.gradle.org/current/javadoc/org/gradle/api/tasks/util/PatternFilterable.html[^].
====
. Добавьте свойство `jmix.ui.widget-set` в ваш файл `application.properties` (настройте местоположение в соответствии с задачей `compileWidgets` выше):
+
[source,properties,indent=0]
----
include::example$/ex1/src/main/resources/application.properties[tags=widget-set]
----

Наборы виджетов компилируются задачей `WidgetsCompile` с названием `compileWidgets`. Она создается автоматически при использовании плагина Jmix.

Скомпилированный набор виджетов помещается в каталог `build/widgets` и будет включен в JAR/WAR артефакт проекта.

[[color-button-gwt-component]]
== Создание компонента ColorButton GWT

В этом разделе мы создадим новый компонент `ColorButton`. Он наследуется напрямую от компонента `JmixButton`.

Кастомные компоненты UI, (то есть компоненты, унаследованные напрямую от компонентов Vaadin) должны быть размещены в подпакете `widgets`, например, `com.company.sample.widgets`. Клиентские компоненты (коннекторы и виджеты), а также классы, используемые для связи на и стороне сервера, и клиента, такие как RPC и State, должны быть помещены в подпакет `widgets.client`, например `com.company.sample.widgets.client`. Подробнее об интеграции client-server можно прочитать в https://vaadin.com/docs/v8/framework/gwt[документации^] Vaadin.

[[component-state-class]]
=== Создание класса состояния компонента

Создайте `ColorButtonState.java` в пакете `widgets.client`.

Класс состояния `ColorButtonState` отвечает за то, какие данные будут пересылаться между клиентом и сервером. В нем определяются публичные поля, которые будут автоматически сериализованы на сервере и десериализованы на клиенте.

.ColorButtonState.java
[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/widgets/client/ColorButtonState.java[tags=color-button-state]
----

[[vaadin-component-class]]
=== Создание класса компонента Vaadin

`ColorButton` является классом компонента Vaadin. Он определяет API для серверного кода, методы доступа, слушатели событий и подключение источников данных. Прикладные разработчики используют в своем коде методы этого класса.

Создайте `ColorButton.java` в пакете `widgets`:

.ColorButton.java
[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/widgets/ColorButton.java[tags=color-button]
----

[[connector]]
=== Создание коннектора

Создайте `ColorButtonConnector.java` в пакете `widgets.client`.

Коннектор `ColorButtonConnector` связывает клиентский код с серверной частью.

.ColorButtonConnector.java
[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/widgets/client/ColorButtonConnector.java[tags=color-button-connector]
----
<1> С помощью этой аннотации коннектор `ColorButtonConnector` помечен как имеющий аналог на стороне сервера. Значение аннотации – `ColorButton`, класс серверной реализации.
<2> Возвращает объект `ColorButtonState` для этого коннектора.
<3> Реагирует на изменение состояния сервера.
<4> Обновляет стиль виджета, если значение на сервере изменилось.

[[using-color-button]]
=== Использование ColorButton

Для демонстрации работы компонента создадим новый экран `color-button-screen`.

Откройте контроллер экрана `ColorButtonScreen.java` и добавьте код размещения компонента на экране:

.ColorButtonScreen.java
[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/components/colorbutton/ColorButtonScreen.java[tags=color-button-screen]
----
<1> Инициализирует экземпляр компонента `ColorButton`.
<2> Получает ссылку на контейнер Vaadin с помощью метода `unwrap()` и добавляет в него новый компонент.

На рисунке ниже показана завершенная структура проекта:

image::custom-components/project-structure.png[align="center"]

Запустите приложение и посмотрите результат:

image::custom-components/color-button.png[align="center"]