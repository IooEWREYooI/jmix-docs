= 打开界面
:page-aliases: backoffice-ui:opening-screens.adoc

可以通过 xref:ui:screens/root-screens.adoc#main-screen[主界面]、xref:ui:actions/standard-actions.adoc[标准操作]（当使用浏览和编辑实体界面时）或从另外一个界面以编程方式打开。在本节，将介绍如何以编程的方式打开界面。
//or by navigating to a URL

[[using-screens-interface]]
== 使用 Screens 接口

`Screens` 接口可以创建和显示任何类型的界面。

假设有一个界面用于展示具有一些特殊格式的消息。界面控制器如下：

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/screens/open/FancyMessageScreen.java[tags=fancy-screen1;label;fancy-screen2;end]
----
<1> 注入 xref:ui:vcl/components/label.adoc[标签] 组件。
<2> 方法接收 `String` 界面参数。
<3> 订阅 `ClickEvent`。

XML 描述文件：

[source,xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/screens/open/fancy-message-screen.xml[tags=fancy-screen]
----

那么可以从另一个界面创建并打开它，如下所示：

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/screens/open/ShowScreens.java[tags=inject-screens;show-screen]
----
<1> 创建界面实例。
<2> 为界面提供参数。
<3> 展示界面。

如果界面不需要来自调用方的任何参数，可以仅用一行代码创建并打开它：

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/screens/open/ShowScreens.java[tags=inject-screens;show-line]
----

NOTE: `Screens` 不是 Spring bean，所以只能将它注入到界面控制器或使用 `ComponentsHelper.getScreenContext(component).getScreens()` 静态方法获取。

[[using-screenbuilders-bean]]
== 使用 ScreenBuilders Bean

`ScreenBuilders` bean 可以使用各种参数打开所有类型的界面。

下面是用它打开界面并且在界面关闭之后执行一些代码的例子：

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/screens/open/ShowScreens.java[tags=screen-builders;notifications;show-other-screen]
----

[[opening-editor-screens]]
=== 打开编辑界面

多数情况下，你会用 xref:ui:actions/standard-actions.adoc[标准操作]，例如 xref:ui:actions/standard-actions/create-action.adoc[CreateAction]，来打开编辑界面。我们看下面的例子使用 `ScreenBuilders` API 从 xref:ui:actions/base-action.adoc[BaseAction] 或 xref:ui:vcl/components/button.adoc[按钮] 处理器直接打开界面。

默认编辑界面的确定过程如下：

. 如果存在使用 xref:ui:screens/annotations.adoc#primary-editor-screen[@PrimaryEditorScreen] 注解的编辑界面，则使用它。
. 否则，使用 id 是 `<entity_name>.edit` 的编辑界面，例如，`sales_Customer.edit`。

为 `Customer` 实体实例打开默认编辑界面的示例：

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/screens/open/ShowScreens.java[tags=screen-builders;edit-customer]
----

在这种情况下，编辑界面将更新实体，但调用界面将不会接收到更新后的实例。

我们经常需要编辑某些用 `Table` 或 `DataGrid` 组件显示的实体。那么应该使用以下调用方式，它更简洁且能自动更新表格组件：

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/screens/open/ShowScreens.java[tags=group-table;screen-builders;edit-from-table]
----

要创建一个新的实体实例并打开它的编辑界面，只需在 builder 调用 `newEntity()` 方法：

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/screens/open/ShowScreens.java[tags=group-table;screen-builders;create]
----

`ScreenBuilder` 提供了许多方法来设置被打开界面的可选参数。例如，以下代码以对话框的方式打开的特定编辑界面，同时新建并初始化实体：

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/screens/open/ShowScreens.java[tags=group-table;screen-builders;edit-customer;create-with-parameter]
----
<1> 初始化新实例。
<2> 指定编辑界面。
<3> 以对话框方式打开。

[[opening-lookup-screens]]
=== 打开查找界面

再看看处理查找界面的例子。与编辑界面一样，多数情况是通过 xref:ui:actions/standard-actions.adoc[标准操作]，例如 xref:ui:actions/standard-actions/entity-lookup-action.adoc[EntityLookupAction] 打开此类界面。下面的示例展示 `ScreenBuilders` API 的用法，如果不想用标准操作的话。

默认查找界面的确定过程如下：

. 如果存在使用 xref:ui:screens/annotations.adoc#primary-lookup-screen[@PrimaryLookupScreen] 注解的查找界面，则使用它。
. 否则，如果存在 id 为 `<entity_name>.lookup` 的界面，则使用它，例如，`sales_Customer.lookup`。
. 否则，使用 id 为 `<entity_name>.browse` 的界面，例如，`sales_Customer.browse`.

实体查找界面也可以使用各种参数打开。下面的示例中，打开了 `Customer` 实体的查找界面，选中 customer 的名称填写在 `textField` 中：

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/screens/open/ShowScreens.java[tags=text-field;screen-builders;lookup]
----

如果将查找实体设置到一个字段中，可以用更简洁的形式：

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/screens/open/ShowScreens.java[tags=entity-picker;screen-builders;lookup-select]
----

与使用编辑界面一样，使用 builder 方法设置打开界面的可选参数。例如，以下代码以对话框的方式打开特定的查找界面，在这个界面中查找 `Customer` 实体：

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/screens/open/ShowScreens.java[tags=text-field;screen-builders;lookup-with-parameter]
----

[[passing-parameters-to-screens]]
== 为界面传递参数

为打开界面传递参数的推荐方式是使用界面控制器的公共 setter 方法，如上面的<<using-screens-interface,示例>>内容。使用这个方式，可以为任意类型的界面传递参数，包括使用<<using-screenbuilders-bean,ScreenBuilders>>或者从主菜单打开的实体编辑和查找界面。

带有传参使用 `ScreenBuilders` 来调用 `FancyMessageScreen` 如下所示：

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/screens/open/ShowScreens2.java[tags=screen-builders;show-fancy-message]
----

如果使用类似 xref:ui:actions/standard-actions/create-action.adoc[CreateAction] 的标准操作打开界面，可以用它的 `screenConfigurer` 处理器通过界面的公共 setters 传递参数。

另一个方式是为参数定义一个特殊的类，然后在 SreenBuilder 中将该类的实例传递给标准的 `withOptions()` 方法。参数类必需实现 `ScreenOptions` 标记接口。示例：

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/screens/open/FancyMessageOptions.java[tags=fancy-options]
----

在打开的 `FancyMessageScreen` 界面，可以通过 xref:ui:screens/screen-events.adoc#init-event[InitEvent] 和 xref:ui:screens/screen-events.adoc#after-init-event[AfterInitEvent] 处理器获取参数：

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/screens/open/FancyMessageScreen.java[tags=label;on-init]
----

带有传递 `ScreenOptions` 参数使用 `ScreenBuilders` 来调用 `FancyMessageScreen` 如下所示：

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/screens/open/ShowScreens3.java[tags=screen-builders;fancy-screen]
----

可以看到，这个方式需要在控制界接收参数的时候进行类型转换，所以需要谨慎使用。推荐还是用上面介绍的类型安全的使用 setter 的方式。

如果使用类似 xref:ui:actions/standard-actions/create-action.adoc#create-action[CreateAction] 的标准操作打开界面，可以用它的 `screenOptionsSupplier` 处理器创建并初始化所需的 `ScreenOptions` 对象。

如果界面是基于老 API 从另一个界面打开的，那么使用 `ScreenOptions` 对象是唯一能获取到参数的方法。此时，参数对象是 `MapScreenOptions` 类型的，可以在打开的界面中按照如下处理：

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/screens/open/FancyMessageScreen2.java[tags=label;on-init]
----

[[executing-code-after-close]]
== 关闭界面后执行代码和返回值

每个界面在关闭时都会发送 `AfterCloseEvent` 事件。可以为界面添加监听器，这样可以在界面关闭时收到通知，示例：

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/screens/open/ShowScreens2.java[tags=screens;notifications;show-other-screen]
----

当使用 `ScreenBuilders` 时，可以在 `withAfterCloseListener()` 方法中提供监听器：

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/screens/open/ShowScreens3.java[tags=screen-builders;notifications;show-other-screen]
----

事件对象能提供关于界面是如何关闭的信息。信息可以有两种方式获取：

* 检测界面是否通过 `StandardOutcome` 枚举类型定义的一种标准输出关闭。
* 获取 `CloseAction` 对象。

前一种方法比较简单，但是后一种方法比较灵活。

先看看第一种方式：使用标准输出关闭界面然后在调用代码内进行检测。将调用下面这个界面：

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/screens/open/OtherScreen.java[tags=other-screen]
----
<1> 在点击 *Ok* 按钮时，设置一些结果状态，并使用 `StandardOutcome.COMMIT` 枚举值关闭界面。
<2> 在点击 *Cancel* 按钮时，使用 `StandardOutcome.CLOSE` 关闭界面。

在 `AfterCloseEvent` 监听器，可以使用事件的 `closedWith()` 方法检查界面是如何关闭的，需要的话可以读取结果：

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/screens/open/ShowScreens4.java[tags=screen-builders;notifications;show-other-screen]
----

[[using-custom-close-action]]
=== 使用自定义的 CloseAction
从界面返回值的另一个方法是使用自定义的 `CloseAction` 实现。重写一下上面的示例，使用如下操作类：

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/screens/open/MyCloseAction.java[tags=my-close-action]
----

然后可以使用该操作类关闭界面：

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/screens/open/NewOtherScreen.java[tags=new-other-screen]
----
<1> 在点击 *Ok* 按钮时，创建自定义关闭操作，并设置结果值。
<2> 在点击 *Cancel* 按钮时，使用框架提供的默认操作关闭界面。

在 `AfterCloseEvent` 监听器中，可以从事件获取 `CloseAction` 并读取结果：

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/screens/open/ShowScreens4.java[tags=screens;notifications;show-new-other-screen]
----

可以看到，当使用自定义的 `CloseAction` 返回值时，调用方不需要知道打开的界面类是什么，因为不会调用具体的界面控制器内的方法。所以界面可以只通过其字符串 id 来创建。

当然，在使用 `ScreenBuilders` 打开界面时，也可以使用相同的方式通过关闭操作返回结果。
