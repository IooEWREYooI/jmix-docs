= Открытие экранов

Экран может быть открыт из xref:ui:screens/root-screens.adoc#main-screen[главного меню], xref:ui:actions/standard-actions.adoc[стандартным действием] при работе с экранами просмотра и редактирования, или программно из другого экрана. В данном разделе рассматривается, как открывать экраны программно.
//или навигацией к URL (backoffice-ui/url-history-navigation)

[[using-screens-interface]]
== Интерфейс Screens

Интерфейс `Screens` позволяет создавать и отображать экраны всех типов.

Предположим, есть экран для демонстрации сообщения с особым форматированием. Контроллер может выглядет таким образом:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/screens/open/FancyMessageScreen.java[tags=fancy-screen1;label;fancy-screen2;end]
----
<1> Инжектирование компонента xref:ui:vcl/components/label.adoc[Label].
<2> Метод принимает параметр экрана `String`.
<3> Подписка на `ClickEvent`.

XML-дескриптор:

[source,xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/screens/open/fancy-message-screen.xml[tags=fancy-screen]
----

Теперь его можно создать и открыть из другого экрана следующим образом:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/screens/open/ShowScreens.java[tags=inject-screens;show-screen]
----
<1> Создает экземпляр экрана.
<2> Передает параметр для экрана.
<3> Показывает экран.

Если экран не требует передачи параметров из вызывающего кода, его можно создать и открыть одной строкой:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/screens/open/ShowScreens.java[tags=inject-screens;show-line]
----

NOTE: Обратите внимание, что `Screens` не является Spring-бином, поэтому его можно только инжектировать в контроллер экрана или получить с помощью статического метода `ComponentsHelper.getScreenContext(component).getScreens()`.

[[using-screenbuilders-bean]]
== Бин ScreenBuilders

Бин `ScreenBuilders` позволяет открывать все типы экранов с различными параметрами.

Ниже приведен пример вызова экрана и выполнения некоторого кода после того, как экран закрывается:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/screens/open/ShowScreens.java[tags=screen-builders;notifications;show-other-screen]
----

[[opening-editor-screens]]
=== Открытие экранов редактирования

В большинстве случаев экраны редактирования открываются с помощью xref:ui:actions/standard-actions.adoc[стандартных действий], таких как xref:ui:actions/standard-actions/create-action.adoc[CreateAction]. Давайте рассмотрим примеры, когда можно использовать API `ScreenBuilders` напрямую для открытия экрана из обработчика xref:ui:actions/base-action.adoc[BaseAction] или xref:ui:vcl/components/button.adoc[Button].

Экран редактирования по умолчанию определяется по следующей схеме:

. Если существует экран редактирования с аннотацией xref:ui:screens/annotations.adoc#primary-editor-screen[@PrimaryEditorScreen], будет использован он.
. Если такого экрана нет, будет использован экран с идентификатором вида `<entity_name>.edit`, например, `sales_Customer.edit`.

Пример открытия редактора по умолчанию для экземпляра сущности `Customer`:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/screens/open/ShowScreens.java[tags=screen-builders;edit-customer]
----

В данном примере редактор изменит экземпляр сущности `Customer`, но вызывающий экран не получит назад обновленную сущность.

Часто требуется отредактировать сущность, отображаемую, к примеру, компонентом `Table` или `DataGrid`. В этом случае следует использовать другую форму вызова редактора, она короче и позволяет автоматически обновить исходный экземпляр в таблице:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/screens/open/ShowScreens.java[tags=group-table;screen-builders;edit-from-table]
----

Чтобы создать новый экземпляр сущности и открыть экран его редактирования, достаточно вызвать метод `newEntity()` builder’а:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/screens/open/ShowScreens.java[tags=group-table;screen-builders;create]
----

`ScreenBuilder` предоставляет множество методов для передачи дополнительных параметров в открываемый экран. К примеру, следующий код создает сущность, сначала инициализируя новый экземпляр, в конкретном экране редактирования, открываемом в режиме диалогового окна:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/screens/open/ShowScreens.java[tags=group-table;screen-builders;edit-customer;create-with-parameter]
----
<1> Инициализирует новый экземпляр.
<2> Указывает экран редактирования.
<3> Открывает диалог.

[[opening-lookup-screens]]
=== Открытие экранов выбора

Рассмотрим несколько примеров работы с экранами выбора. Как и в случае с экранами редактора, в основном такие экраны открываются с помощью xref:ui:actions/standard-actions.adoc[стандартных действий], таких как действие xref:ui:actions/standard-actions/entity-lookup-action.adoc[EntityLookupAction]. Приведенные ниже примеры показывают использование API `ScreenBuilders` и могут быть полезны, если стандартные действия не используются.

Экран выбора по умолчанию определяется по следующей схеме:

. Если существует экран выбора с аннотацией xref:ui:screens/annotations.adoc#primary-lookup-screen[@PrimaryLookupScreen], будет использован он.
. Если такого экрана нет, будет использован экран с идентификатором вида `<entity_name>.lookup`, например, `sales_Customer.lookup`.
. Если и такого экрана нет, будет использован экран с идентификатором вида `<entity_name>.browse`, например, `sales_Customer.browse`.

Экраны выбора сущностей также можно открывать с различными параметрами. В приведенном ниже примере открывается экран выбора сущности `Customer`, и имя выбранного клиента записывается в `textField`:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/screens/open/ShowScreens.java[tags=text-field;screen-builders;lookup]
----

Если нужно установить выбранную сущность в качестве значения поля, используйте краткую форму вызова:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/screens/open/ShowScreens.java[tags=entity-picker;screen-builders;lookup-select]
----

Как и в случае с экранами редактирования, можете использовать методы builder’а для передачи дополнительных параметров в открываемые экраны. Например, следующий код выбирает сущность `Customer` в конкретном экране выбора, открываемом в режиме диалогового окна:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/screens/open/ShowScreens.java[tags=text-field;screen-builders;lookup-with-parameter]
----

[[passing-parameters-to-screens]]
== Передача параметров в экраны

Рекомендуемый способ передачи параметров в открываемый экран – использование публичных setter-методов контроллера, как продемонстрировано в примере <<using-screens-interface,выше>>. С помощью такого подхода можно передавать параметры в экраны любого типа, в том числе экраны редактирования и выбора сущностей, открываемые через <<using-screenbuilders-bean,ScreenBuilders>> или из главного меню.

Пример вызова `FancyMessageScreen` с передачей параметра и использованием `ScreenBuilders`:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/screens/open/ShowScreens2.java[tags=screen-builders;show-fancy-message]
----

Если экран открывается из стандартного действия, такого как xref:ui:actions/standard-actions/create-action.adoc[CreateAction], используйте его обработчик `screenConfigurer` для передачи параметров через публичные сеттеры контроллера экрана.

Другой способ – определить специальный класс для параметров и передавать экземпляр этого класса в стандартный метод `withOptions()` билдера. Класс параметров должен реализовывать маркер-интерфейс `ScreenOptions`. Например:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/screens/open/FancyMessageOptions.java[tags=fancy-options]
----

В открываемом экране `FancyMessageScreen`, объект параметров может быть получен в обработчиках xref:ui:screens/screen-events.adoc#init-event[InitEvent] и xref:ui:screens/screen-events.adoc#after-init-event[AfterInitEvent]:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/screens/open/FancyMessageScreen.java[tags=label;on-init]
----

Пример вызова экрана `FancyMessageScreen` через `ScreenBuilders` с передачей `ScreenOptions`:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/screens/open/ShowScreens3.java[tags=screen-builders;fancy-screen]
----

Как видите, данный подход требует приведения типов в контроллере, получающем параметры, поэтому используйте его только когда это необходимо и предпочитайте type-safe подход с setter-методами, описанный выше.

Если экран открывается из стандартного действия, такого как xref:ui:actions/standard-actions/create-action.adoc#create-action[CreateAction], используйте его обработчик `screenOptionsSupplier` для создания и инициализации требуемого объекта `ScreenOptions`.

Использование объекта `ScreenOptions` является единственным способом получения параметров, если экран открывается из другого экрана, основанного на устаревшем API. В этом случае объект параметров имеет тип `MapScreenOptions` и может быть обработан следующим образом:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/screens/open/FancyMessageScreen2.java[tags=label;on-init]
----

[[executing-code-after-close]]
== Выполнение кода после закрытия и возврат значений

Каждый экран посылает событие `AfterCloseEvent` после своего закрытия. Экрану можно добавить слушатель для уведомления об этом событии, например:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/screens/open/ShowScreens2.java[tags=screens;notifications;show-other-screen]
----

При использовании `ScreenBuilders`, слушатель можно передать в методе `withAfterCloseListener()`:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/screens/open/ShowScreens3.java[tags=screen-builders;notifications;show-other-screen]
----

Объект события предоставляет информацию о том, как экран был закрыт. Эта информация может быть получена двумя способами:

* Проверкой, был ли экран закрыт с одним из стандартных значений перечисления `StandardOutcome`.
* Получением объекта `CloseAction`. Первый способ проще, второй более гибкий.

Рассмотрим первый подход: закрытие экрана с указанием `StandardOutcome` и его проверкой в вызывающем коде. Вызывается следующий экран:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/screens/open/OtherScreen.java[tags=other-screen]
----
<1> При нажатии кнопки *Ok*, установить некоторое результирующее значение и закрыть экран со значением перечисления `StandardOutcome.COMMIT`.
<2> При нажатии кнопки *Cancel*, закрыть экран с `StandardOutcome.CLOSE`.

Теперь в слушателе `AfterCloseEvent` можно проанализировать, как экран был закрыт, с помощью метода `closedWith()` события, и, если необходимо, прочитать возвращаемое экраном значение:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/screens/open/ShowScreens4.java[tags=screen-builders;notifications;show-other-screen]
----

[[using-custom-close-action]]
=== Использование собственного CloseAction
Другим способом возврата значений из экранов является использование собственных реализаций `CloseAction`. Перепишем пример, приведенный выше, с использованием следующего класса действия закрытия:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/screens/open/MyCloseAction.java[tags=my-close-action]
----

Теперь можно использовать данное действие при закрытии экрана:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/screens/open/NewOtherScreen.java[tags=new-other-screen]
----
<1> При нажатии кнопки *Ok*, создать экземпляр `CloseAction` и передать ему результирующее значение.
<2> При нажатии кнопки *Cancel*, закрыть экран с действием закрытия по умолчанию, предоставляемым фреймворком.

В слушателе `AfterCloseEvent` можно получить `CloseAction` из объекта события и прочитать результирующее значение:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/screens/open/ShowScreens4.java[tags=screens;notifications;show-new-other-screen]
----

Как видно из примера кода, при возврате значений через собственный `CloseAction`, вызывающий код не обязан знать класс открываемого экрана, так как ему не нужено вызывать его методы. Поэтому экран можно создавать по его строковому идентификатору.

Разумеется, данный подход к возврату значений через действия закрытия может использоваться и при открытии экранов с помощью `ScreenBuilders`.
