= DataContext

Интерфейс `DataContext` позволяет отслеживать изменения в сущностях, загружаемых на уровень UI. Отслеживаемые сущности помечаются как "грязные" при любом изменении их атрибутов, и `DataContext` сохраняет грязные экземпляры при вызове его метода `commit()`.

Внутри `DataContext` сущность с некоторым идентификатором будет представлена как единственный объект, вне зависимости от того, где и сколько раз она использована в графах других объектов.

Чтобы сущность отслеживалась, ее необходимо поместить в `DataContext` с помощью метода `merge()`. Если контекст не содержит экземпляра сущности с таким же идентификатором, то контекст создает новый экземпляр и копирует в него состояние переданного. Если контекст уже содержит экземпляр сущности с таким же идентификатором, он копирует в имеющегося состояние переданного и возвращает. Данный механизм позволяет всегда иметь в контексте не более одного экземпляра сущности с конкретным идентификатором.

При помещении сущности в контекст методом `merge()` весь граф объектов с корнем в данной сущности также помещается в контекст. То есть все связанные сущности, включая коллекции, становятся отслеживаемыми.

NOTE: Главный принцип использования метода `merge()` заключается в том, чтобы продолжать работать с возвращенным экземпляром, забывая про переданный. В большинстве случаев возвращенный экземпляр будет другим. Единственное исключение – если в `merge()` передан экземпляр объекта, ранее возвращенный другим вызовом `merge()` или `find()` этого же контекста.

Пример помещения сущности в `DataContext`:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/data/DepartmentBrowseData2.java[tags=data-context;data-manager;collection;load]
----

Для одного экрана и всех его вложенных фрагментов может существовать только один экземпляр `DataContext`. Он создается автоматически, если в XML-дескрипторе экрана существует элемент `<data>`.

Элемент `<data>` может содержать атрибут `readOnly="true"`, в этом случае будет использована специальная "no-op"-реализация, в которой не будут отслеживаться изменения в сущностях и, следовательно, улучшится быстродействие. Экраны просмотра списков, автоматически создаваемые в Studio, по умолчанию имеют read-only data context, поэтому если вам нужно отслеживать изменения и сохранять грязные сущности в браузере, удалите XML-атрибут `readOnly="true"`.

CAUTION: If a referenced entity is not included in the xref:data-access:fetching.adoc#fetch-plan[fetch plan] of the screen but loaded by xref:data-access:fetching.adoc#lazy-loading[lazy loading], it is not merged into the screen's `DataContext` and hence not tracked for changes. Make sure all entities edited on the screen are loaded eagerly by including references to them in the fetch plan.

[[obtaining-data-context]]
== Получение DataContext

. `DataContext` экрана можно получить в его контроллере используя инжектирование:
+
[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/data/DepartmentBrowseData2.java[tags=data-context]
----
+
. Если имеется ссылка на некоторый экран, то получить его `DataContext` можно с помощью класса `UiControllerUtils`:
+
[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/data/DepartmentBrowseData.java[tags=sample-method]
----
+
. UI-компонент может получить `DataContext` текущего экрана следующим образом:
+
[source,java,indent=0]
----
DataContext dataContext = UiControllerUtils.getScreenData(getFrame().getFrameOwner()).getDataContext();
----

[[parent-data-context]]
== Родительский DataContext

Сущности `DataContext` могут образовывать отношения предок-потомок. Если у экземпляра `DataContext` есть родительский контекст, он будет сохранять измененные сущности в своего предка вместо того, чтобы сразу отправлять их в хранилище данных. Эта особенность позволяет редактировать композитные сущности, где дочерние сущности должны сохраняться только вместе с родительской. Если атрибут сущности снабжен аннотацией `@Composition`, фреймворк автоматически установит родительский контекст для экрана редактирования этого атрибута, чтобы измененная сущность атрибута могла быть сохранена только вместе с основной сущностью.

Подобное поведение можно легко настроить вручную для любой сущности или экрана.

Если вы программно открываете экран редактирования сущности, который должен сохранять изменения в data context текущего экрана, используйте метод `withParentDataContext()` builder’а:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/data/PersonBrowseCondition.java[tags=screen-builders;data-context;person-edit]
----

Если вы открываете простой экран с помощью бина `Screens`, определите в нем сеттер, принимающий data context родительского экрана:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/data/SmplScreen.java[tags=sample-screen]
----

И используйте после создания экрана:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/data/PersonBrowseCondition.java[tags=screens;data-context;sample-screen]
----

CAUTION: Убедитесь, что для родительского data context не задан атрибут `readOnly="true"`. В противном случае при попытке использовать его как предка другого контекста будет выброшено исключение.

[[data-context-events]]
== События и слушатели

В этом разделе описываются события жизненного цикла DataContext, на которые можно подписаться в контроллерах экрана.

include::events-handlers-generation-data-tip.adoc[]

[[change-event]]
=== ChangeEvent

Это событие отправляется, когда `DataContext` обнаруживает изменения в отслеживаемой сущности, в контекст помещается новый экземпляр или при удалении сущности.

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/data/DataContextEvents.java[tags=change-event]
----

[[post-commit-event]]
=== PostCommitEvent

Это событие отправляется после коммита изменений.
Из слушателя этого события можно получить коллекцию закоммиченных сущностей, возвращенных из `DataManager` или настраиваемого <<commit-delegate,commitDelegate>>. Эти сущности уже помещены в `DataContext`. Например:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/data/DataContextEvents.java[tags=post-commit-event]
----

[[pre-commit-event]]
=== PreCommitEvent

Это событие отправляется перед коммитом изменений.
В слушателе этого события можно добавлять произвольные экземпляры сущностей в закоммиченные коллекции, возвращаемые методами `getModifiedInstances()` и `getRemovedInstances()`, например:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/data/DataContextEvents.java[tags=pre-commit-event]
----

Вы также можете предотвратить коммит, используя метод события `preventCommit()`, например:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/data/DataContextEvents.java[tags=prevent-commit]
----

[[commit-delegate]]
=== CommitDelegate

По умолчанию `DataContext` сохраняет измененные и удаленные объекты с помощью метода xref:data-access:data-manager.adoc#save[DataManager.save(SaveContext)]. Слушатель `commitDelegate` позволяет настраивать логику сохранения данных, что особенно полезно при работе с xref:data-model:entities.adoc#dto[DTO сущностями]. Например, вы можете сохранить измененные объекты с помощью специальной службы (service):

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/data/DataContextEvents.java[tags=commit-delegate]
----