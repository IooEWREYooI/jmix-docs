= DataContext

Интерфейс `DataContext` позволяет отслеживать изменения в сущностях, загружаемых на уровень UI. Отслеживаемые сущности помечаются как "грязные" при любом изменении их атрибутов, и `DataContext` сохраняет грязные экземпляры при вызове его метода `commit()`.

Внутри `DataContext` сущность с некоторым идентификатором будет представлена как единственный объект, вне зависимости от того, где и сколько раз она использована в графах других объектов.

Чтобы сущность отслеживалась, ее необходимо поместить в `DataContext` с помощью метода `merge()`. Если контекст не содержит экземпляра сущности с таким же идентификатором, то контекст создает новый экземпляр и копирует в него состояние переданного. Если контекст уже содержит экземпляр сущности с таким же идентификатором, он копирует в имеющегося состояние переданного и возвращает. Данный механизм позволяет всегда иметь в контексте не более одного экземпляра сущности с конкретным идентификатором.

При помещении сущности в контекст методом `merge()` весь граф объектов с корнем в данной сущности также помещается в контекст. То есть все связанные сущности, включая коллекции, становятся отслеживаемыми.

NOTE: Главный принцип использования метода `merge()` заключается в том, чтобы продолжать работать с возвращенным экземпляром, забывая про переданный. В большинстве случаев возвращенный экземпляр будет другим. Единственное исключение – если в `merge()` передан экземпляр объекта, ранее возвращенный другим вызовом `merge()` или `find()` этого же контекста.

Пример помещения сущности в `DataContext`:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/data/DepartmentBrowseData2.java[tags=data-context;data-manager;collection;load]
----

Для одного экрана и всех его вложенных фрагментов может существовать только один экземпляр `DataContext`. Он создается автоматически, если в XML-дескрипторе экрана существует элемент `<data>`.

Элемент `<data>` может содержать атрибут `readOnly="true"`, в этом случае будет использована специальная "no-op"-реализация, в которой не будут отслеживаться изменения в сущностях и, следовательно, улучшится быстродействие. Экраны просмотра списков, автоматически создаваемые в Studio, по умолчанию имеют read-only data context, поэтому если вам нужно отслеживать изменения и сохранять грязные сущности в браузере, удалите XML-атрибут `readOnly="true"`.

[[obtaining-data-context]]
== Получение DataContext

. `DataContext` экрана можно получить в его контроллере используя инжектирование:
+
[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/data/DepartmentBrowseData2.java[tags=data-context]
----
+
. Если имеется ссылка на некоторый экран, то получить его `DataContext` можно с помощью класса `UiControllerUtils`:
+
[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/data/DepartmentBrowseData.java[tags=sample-method]
----
+
. UI-компонент может получить `DataContext` текущего экрана следующим образом:
+
[source,java,indent=0]
----
DataContext dataContext = UiControllerUtils.getScreenData(getFrame().getFrameOwner()).getDataContext();
----

[[parent-data-context]]
== Родительский DataContext

Сущности `DataContext` могут образовывать отношения предок-потомок. Если у экземпляра `DataContext` есть родительский контекст, он будет сохранять измененные сущности в своего предка вместо того, чтобы сразу отправлять их в хранилище данных. Эта особенность позволяет редактировать композитные сущности, где дочерние сущности должны сохраняться только вместе с родительской. Если атрибут сущности снабжен аннотацией `@Composition`, фреймворк автоматически установит родительский контекст для экрана редактирования этого атрибута, чтобы измененная сущность атрибута могла быть сохранена только вместе с основной сущностью.

Подобное поведение можно легко настроить вручную для любой сущности или экрана.

Если вы программно открываете экран редактирования сущности, который должен сохранять изменения в data context текущего экрана, используйте метод `withParentDataContext()` builder’а:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/data/PersonBrowseCondition.java[tags=screen-builders;data-context;person-edit]
----

Если вы открываете простой экран с помощью бина `Screens`, определите в нем сеттер, принимающий data context родительского экрана:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/data/SmplScreen.java[tags=sample-screen]
----

И используйте после создания экрана:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/data/PersonBrowseCondition.java[tags=screens;data-context;sample-screen]
----

CAUTION: Убедитесь, что для родительского data context не задан атрибут `readOnly="true"`. В противном случае при попытке использовать его как предка другого контекста будет выброшено исключение.

[[data-context-events]]
== Events and Handlers

This section describes the DataContext lifecycle events that can be handled in screen controllers.

include::events-handlers-generation-data-tip.adoc[]

[[change-event]]
=== ChangeEvent

This event is sent when the context detects changes in a tracked entity, a new instance is merged or an entity is removed.

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/data/DataContextEvents.java[tags=change-event]
----

[[post-commit-event]]
=== PostCommitEvent

This event is sent after committing changes.
In this event listener, you can get the collection of committed entities returned from `DataManager` or a custom <<commit-delegate,commit delegate>>. These entities are already merged into the DataContext. For example:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/data/DataContextEvents.java[tags=post-commit-event]
----

[[pre-commit-event]]
=== PreCommitEvent

This event is sent before committing changes.
In this event listener, you can add arbitrary entity instances to the committed collections returned by `getModifiedInstances()` and `getRemovedInstances()` methods, for example:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/data/DataContextEvents.java[tags=pre-commit-event]
----

You can also prevent the commit using the `preventCommit()` method of the event, for example:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/data/DataContextEvents.java[tags=prevent-commit]
----

[[commit-delegate]]
=== CommitDelegate

By default, `DataContext` commits changed and removed entities using the xref:data-access:data-manager.adoc#save[DataManager.save(SaveContext)] method. The `commitDelegate` handler allows you to customize the logic of saving data, which is especially useful when working with xref:data-model:entities.adoc#dto[DTO entities]. For example, you can save the changed entities with a custom service:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/data/DataContextEvents.java[tags=commit-delegate]
----