= Использование компонентов данных

В данном разделе рассмотрены практические примеры работы с компонентами данных.

[[declarative-usage]]
== Декларативное использование

Обычно компоненты данных определяются и привязываются к визуальным компонентам декларативно в XML-дескрипторе экрана. При создании экрана для сущности с помощью Studio, можно увидеть корневой элемент `<data>`, содержащий объявления компонентов данных.

Ниже приведен пример компонентов данных на экране редактирования для сущности `Employee`, который содержит to-one ссылку на `Department` и to-many ссылку на сущность `EquipmentLine`:

//Defining data components in the screen XML descriptor is the simplest way to create them.
//Самый простой способ создать компоненты данных – это определить их в XML-дескрипторе экрана внутри элемента `<data>`.

//Рассмотрим для примера модель данных, содержащую сущности `Employee`, `Department` и `EquipmentLine`. Экран редактирования сущности `Employee` может иметь следующее XML-определение:

[source,xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/entity/employee/employee-edit.xml[tags=xml]
----
<1> Корневой элемент `data` определяет экземпляр xref:data/data-context.adoc[DataContext].
<2> Контейнер `InstanceContainer` сущности `Employee`.
<3> Опциональный атрибут xref:data-access:fetching.adoc#fetch-plan[fetchPlan] определяет граф объектов, который должен быть жадно загружен из базы данных.
<4> `InstanceLoader`, загружающий экземпляры сущности `Employee`.
<5> Контейнер `CollectionPropertyContainer` для вложенной сущности `EquipmentLine`. Этот контейнер привязан к атрибуту-коллекции `Employee.equipment`.
<6> Контейнер `CollectionContainer` для сущности `Department`.
<7> `CollectionLoader`, загружающий экземпляры сущности `Department` по определенному запросу.

Заданные выше контейнеры данных могут использоваться в визуальных компонентах следующим образом:

[source,xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/entity/employee/employee-edit.xml[tags=layout1;layout2]
----
<1> Отдельные поля имеют атрибуты `dataContainer` и `property`.
<2> Элемент `form` распространяет свой `dataContainer` на все вложенные поля, поэтому они требуют только указания атрибута `property`.
<3> Поле `EntityComboBox` имеет атрибут `optionsContainer` для получения списка опций.
<4> У таблиц есть только атрибут `dataContainer`.

[[programmatic-usage]]
== Программное использование

Компоненты данных можно создавать и использовать программно.

В следующем примере мы создадим экран редактирования с тем же данными и визуальными компонентами, которые мы определяли декларативно в предыдущем примере, на чистой Java без XML-дескриптора.

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/data/EmployeeEditExample.java[tags=progr]
----
<1> `DataComponents` - это фабрика для создания компонентов данных.
<2> Регистрируем в экране экземпляр `DataContext`, чтобы обеспечить работу стандартного действия commit.
<3> Загрузчик `employeeDl` загружает данные в контейнер `employeeDc`.
<4> Загрузчик `employeeDl` помещает загруженные сущности в data context для отслеживания изменений.
<5> `equipmentDc` создается как контейнер свойства.
<6> Определяем запрос для загрузчика `departmentsDl`.
<7> `ContainerValueSource` используется для связи одиночных полей с контейнерами данных.
<8> `ContainerOptions` предоставляет список опций для полей выбора.
<9> `ContainerTableItems` используется для связи таблиц с контейнерами.
<10> Переопределяем `getEditedEntityContainer()`, чтобы указать контейнер, вместо аннотации `@EditedEntityContainer`.
<11> Загружаем данные перед отображением экрана. Идентификатор редактируемой сущности будет автоматически передан в загрузчик `employeeDl`.

[[dependencies-between-data-components]]
== Зависимости между компонентами данных

Иногда требуется загружать и отображать данные, которые зависят от других данных в том же экране. К примеру, на скриншоте ниже таблица слева отображает список сотрудников, а таблица справа – список оборудования для выбранного сотрудника. Список справа обновляется каждый раз, когда меняется выбранный элемент в таблице слева.

image::data/depend-tables.png[align="center"]

В этом примере сущность `Employee` содержит атрибут `equipment`, который является коллекцией с отношением one-to-many. Самый простой способ реализации экрана – загружать список заказов с xref:data-access:fetching.adoc#fetch-plan[фетч-планом], содержащим атрибут `equipment`, и использовать xref:ui:data/property-containers.adoc[контейнер свойств] для работы со списком зависимых строк. Затем мы связываем левую таблицу с родительским контейнером, а правую – с контейнером свойства.

Однако этот подход может иметь последствия для производительности, ведь мы загружаем все строки для всех сотрудников из левой таблицы, несмотря на то, что в один момент времени отображаются строки только для одного выбранного сотрудника. Поэтому мы рекомендуем использовать контейнеры свойств и расширенные фетч-планы только тогда, когда нужно загрузить единственный экземпляр родительской сущности: например, в экране редактирования одного сотрудника.

Кроме того, родительская сущность может не иметь прямого атрибута, указывающего на зависимую сущность. В этом случае подход с использованием контейнера свойств совсем не подходит.

Наилучшей практикой организации отношений между данными в экране является использование запросов с параметрами. Зависимый загрузчик содержит запрос с параметром, который связывает данные с родительским контейнером, и когда меняется текущий экземпляр в родительском контейнере, мы передаем его в качестве параметра и вызываем зависимый загрузчик.

Рассмотрим пример экрана, в котором есть две зависимых пары контейнер/загрузчик и привязанные к ним таблицы для отображения данных.

[source,xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/data/employee-depend-tables.xml[tags=depend]
----
<1> Родительский контейнер и загрузчик.
<2> Дочерний контейнер и загрузчик.
<3> Фасет xref:ui:facets/data-load-coordinator.adoc[DataLoadCoordinator] не используется, поэтому загрузчики не будут вызваны автоматически.
<4> Основная таблица.
<5> Зависимая таблица.

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/data/EmployeeDependTables.java[tags=depend]
----
<1> Родительский загрузчик вызывается обработчиком `BeforeShowEvent`.
<2> В обработчике родительского контейнера `ItemChangeEvent` передаем параметр в зависимый загрузчик и вызываем его.

TIP: Фасет xref:ui:facets/data-load-coordinator.adoc[DataLoadCoordinator] позволяет устанавливать связи между компонентами данных декларативно без написания кода на Java.

[[using-screen-parameters-in-loaders]]
== Использование параметров экрана в загрузчиках

Часто бывает необходимо загружать данные в экране в зависимости от параметров, переданных в этот экран. В данном разделе приведен пример экрана, принимающего параметр и использующего его для фильтрации загружаемых данных.

Предположим, имеются две сущности: `Country` и `City`. У сущности `City` есть атрибут `country`, который является ссылкой на `Country`. Экран со списком городов принимает экземпляр страны и отображает города только этой страны.

Рассмотрим XML-дескриптор экрана со списком городов. Его загрузчик содержит запрос с параметром:

[source,xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/data/city-browse.xml[tags=loader]
----

Контроллер экрана городов содержит публичный метод-setter для параметра и использует этот параметр в обработчике `BeforeShowEvent`.

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/data/CityBrowse.java[tags=controller]
----

Экран городов можно вызвать из другого экрана, передавая параметр, как показано ниже:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/data/ShowCities.java[tags=show]
----

[[custom-sorting]]
== Специализированная сортировка

Сортировка таблиц по атрибутам сущности в UI производится объектом типа `CollectionContainerSorter`, который устанавливается для xref:ui:data/collection-container.adoc[CollectionContainer]. Стандартная реализация сортирует данные в памяти, если загруженный список умещается на одну страницу, или посылает запрос с соответствующим "order by" в базу данных. Выражение "order by" формируется бином `JpqlSortExpressionProvider`.

Некоторые атрибуты могут потребовать специальной реализации сортировки. Ниже рассматривается простой пример: предположим, в сущности `Order` есть атрибут `number` типа `String`, но на самом деле атрибут хранит только числовые значения. Поэтому необходимо иметь порядок сортировки для чисел: `1`, `2`, `3`, `10`, `11`. Стандартный механизм сортировки в данном случае выдаст порядок `1`, `10`, `11`, `2`, `3`.

Сначала создайте наследника класса `CollectionContainerSorter` для сортировки в памяти:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/data/sort/CustomCollectionContainerSorter.java[tags=sorter]
----

Создайте сортировщик в нужном экране:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/data/sort/OrderBrowseExample.java[tags=screen]
----

Если же специализированная сортировка должна являться глобальной, то создайте собственную фабрику, которая будет инстанциировать сортировщик для всей системы:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/data/sort/CustomSorterFactory.java[tags=factory]
----

Также можно создать собственную реализацию `JpqlSortExpressionProvider` для сортировки на уровне базы данных:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/data/sort/CustomSortExpressionProvider.java[tags=provider]
----