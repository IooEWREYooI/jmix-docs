= Загрузчики данных

Загрузчики, или loaders, предназначены для загрузки данных в xref:ui:data/data-containers.adoc[контейнеры].

Интерфейсы загрузчиков немного отличаются в зависимости от типа контейнера, с которым они работают:

* `InstanceLoader` загружает единственный экземпляр сущности в контейнер `InstanceContainer` по идентификатору сущности или с помощью JPQL-запроса.
* `CollectionLoader` загружает коллекцию сущностей в `CollectionContainer` с помощью JPQL-запроса. Для этого загрузчика можно настроить пейджинг, сортировку и другие дополнительные параметры.
* `KeyValueCollectionLoader` загружает коллекцию экземпляров `KeyValueEntity` в контейнер `KeyValueCollectionContainer`. Кроме параметров, доступных для `CollectionLoader`, вы также можете указать имя хранилища данных.

В XML-дескрипторах экрана загрузчики объявляются с помощью элемента `<loader>`, и тип загрузчика будет определяться типом контейнера, в который он вложен.

Использование загрузчиков необязательно, так как вы можете загружать данные с помощью `DataManager` или собственного сервиса и самостоятельно добавлять их в контейнеры, однако загрузчики облегчают этот процесс для экранов, описываемых декларативно, особенно в случае компонента xref:ui:vcl/components/filter.adoc[Filter].

Обычно загрузчик коллекций получает запрос JPQL из XML-дескриптора экрана, а параметры запроса – из компонента `Filter`, затем создает объект `LoadContext` и вызывает `DataManager` для загрузки сущностей. В итоге XML-дескриптор выглядит подобным образом:

[source,xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/data/customer-browse-data2.xml[tags=loaders1;loaders2;loaders3]
----

В экране редактора сущности XML-элемент `loader` обычно пуст, так как для загрузки единственного экземпляра сущности требуется ее идентификатор, который устанавливается программно классом `StandardEditor`:

[source,xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/data/customer-edit-data2.xml[tags=loaders1]
----

Загрузчики могут делегировать непосредственно загрузку данных отдельной функции, переданной с помощью метода `setLoadDelegate()` либо декларативно с помощью аннотации `@Install` в контроллере экрана, например:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/data/CustomerBrowseData2.java[tags=data-manager;delegate]
----
<1> Метод `customersDlLoadDelegate()` используется загрузчиком `customersDl` для получения списка экземпляров сущности `Customer`.
<2> Метод принимает `LoadContext`, который будет создан загрузчиком на основе его параметров: запрос, фильтр (при наличии) и т.д.
<3> В этом примере загрузка осуществляется через интерфейс `DataManager`, который функционально повторяет стандартную реализацию загрузчика, однако вы можете использовать собственный сервис или же выполнить пост-обработку загруженных сущностей.

[WARNING]
====
If you declare custom data loading with delegation, and you display the loaded data in the table with a pagination component (xref:vcl/components/pagination.adoc[Pagination] or xref:vcl/components/simple-pagination.adoc[SimplePagination]), then most likely you also need to define the custom logic to count total number of rows. Take a look at xref:vcl/components/simple-pagination.adoc#total-count-delegate[TotalCountDelegate] handler for the `SimplePagination` component associated with the table.
====

Загрузчики посылают события `PreLoadEvent` и `PostLoadEvent`, которые можно использовать для выполнения некоторой логики до или после загрузки:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/data/CustomerBrowseData2.java[tags=load]
----

Загрузчики также можно создавать и настраивать программно, к примеру:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/data/CustomerTable.java[tags=data-components;loader;create-loader]
----

Если для загрузчика установлен xref:ui:data/data-context.adoc[DataContext] (как всегда бывает в случае, если загрузчик задан в XML-дескрипторе), все загруженные сущности будут автоматически помещены в data context.

[[quiery-conditions]]
== Условия запросов

Иногда необходимо изменить запрос загрузчика данных во время выполнения программы для того, чтобы отфильтровать загружаемые данные на уровне БД. Простейший способ фильтрации в зависимости от параметров, вводимых пользователем – это подключить к загрузчику визуальный компонент xref:ui:vcl/components/filter.adoc[Filter].

Вместо использования универсального фильтра, или в дополнение к нему, для запроса в загрузчике можно задать набор условий. Условие представляет собой набор фрагментов запросов с параметрами. Эти фрагменты будут добавлены в результирующий запрос, только если все параметры, используемые во фрагментах, заданы для запроса. Условия обрабатываются на уровне хранилищ данных, поэтому они могут содержать фрагменты различных языков запросов, поддерживаемых хранилищами. Фреймворк предоставляет возможность описывать условия на языке JPQL.

Рассмотрим создание условий для фильтрации сущности `Person` по ее атрибуту `name`.

Условия запроса для загрузчика могут быть заданы либо декларативно в XML-элементе `<condition>`, либо программно методом `setCondition()`. Ниже приведен пример описания условий в XML:

[source,xml,indent=0]
----
include::example$/ex1/src/main/resources/ui/ex1/screen/data/person-browse-condition.xml[tags=condition-data]
----
<1> Добавьте namespace для JPQL-условий.
<2> Добавьте элемент `condition` внутри `query`.
<3> Если необходимо задать более одного условия, добавьте элемент `and` или `or`.
<4> Задайте JPQL-условие с опциональным элементом `join` и обязательным `where`.

Предположим, что в экране имеется два UI-компонента для ввода параметров условий: текстовое поле `nameFilterField` и флажок `statusFilterField`. Для того чтобы обновить данные, когда пользователь изменяет значения в этих компонентах, добавим следующие подписки на события в контроллере экрана:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/ui/ex1/screen/data/PersonBrowseCondition.java[tags=loader;condition]
----

Как было упомянуто выше, условие включается в запрос только когда его параметры установлены. Поэтому результирующий запрос, выполняемый БД, будет зависеть от того, что введено в UI-компонентах:

.Only nameFilterField has a value
[source,jpql,indent=0]
----
select e from uiex1_Person e where e.name like :name
----

.Only statusFilterField has a value
[source,jpql,indent=0]
----
select e from uiex1_Person e where e.status = :status
----

.Both nameFilterField and statusFilterField have values
[source,jpql,indent=0]
----
select e from uiex1_Person e where (e.name like :name) and (e.status = :status)
----