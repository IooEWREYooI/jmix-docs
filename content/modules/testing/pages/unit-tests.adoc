= Unit Tests

A unit test is the smallest variant of creating an automated test. By default Jmix automatically includes https://junit.org/junit5/[JUnit 5] as the test runner as well as https://site.mockito.org/[Mockito] for mocking of dependencies.

NOTE: The term "Unit test" is used to describe different concepts. Often it is also used to describe an automated testing in general. We will refer to a unit test as an automated test that verifies behaviour on a particular class / set of classes without dependencies (mainly Spring context and database).

== Testing isolated functionality

In order to show the way how a unit test is created, let's look at some example functionality: calculating a total for a given list order `OrderLine` instance that are associated to an `Order`.

For this there is a dedicated class `OrderAmountCalculation` which holds this calculation. This calculation class is not a Spring bean, but just a regular Java class.

[source,java,indent=0]
----
include::example$/ex1/src/main/java/testing/ex1/order/OrderAmountCalculation.java[tags=order-amount-calculation]
----


[source,java,indent=0]
----
include::example$/ex1/src/test/java/testing/ex1/order/OrderAmountCalculationTest.java[tags=unit-test-total-amount-calculation]
----
<1> The `OrderAmountCalculation` class is instantiated without the use of Spring through the constructor.
<2> Entities are created by calling the constructor (without the usage of Jmix `Metadata` APIs).
<3> Assertion of the calculation result is done via AssertJ assertions.

This test class does not contain any Spring Boot test annotations (like `@SpringBootTest`). This causes the Startup of the test to be much faster compared to a Spring Boot integration test.

But the lack of the Spring context in the test also means, that it is not possible use `@Autowired` in the test case to get instances of Jmix / Spring beans. In case the class of the production code, that is under test has any dependencies to other Spring beans, those dependencies have to be manually injected.

== Mocking with Mockito

For Unit tests in particular this limitation is acceptable as the scope of the test case is normally an isolated functionality of one class.

Let's assume the following example: we have a class that uses Jmix's `TimeSource` API to get the current date. This is used to count the number of bookings that have been placed in this year for a given customer.

Here is the implementation of that class:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/testing/ex1/order/RecentOrdersCounter.java[tags=recent-order-counter]
----

The class is annotated with `@Component` to let Spring automatically inject the dependencies.

We want to test this functionality as a unit test. Therefore, we need to manually instantiate the `RecentOrdersCounter` class. For our concrete test case, we want to check the following:

> Assuming we have two orders: one from 2019 and one from 2020, when the current year is 2020 we expect to have a count of one.

To achieve this, we need to control what `TimeSource` returns as now. This way we can simulate the fact that the current year is 2020.

Mockito is a mocking library that supports this kind of emulation. Jmix includes Mockito by default.

Here is an example on how this test case could look like:

[source,java,indent=0]
----
include::example$/ex1/src/test/java/testing/ex1/order/RecentOrdersCounterTest.java[tags=recent-order-counter-test]
----
<1> the `mock` method creates an emulation instance that we can use to control the behaviour of the class.
<2> we define that when the method `now` is called on the `TimeSource`, it should return `2020-03-01` as `ZonedDateTime`.
<3> when instantiating the counter class, the mock / emulation instance of the `TimeSource` will be passed into the constructor.

TIP: When you want to test your Spring components in a unit test, it is best to use constructor based injection instead of `@Autowired` in the class. It has the main benefit that passing in the mocked instance via the constructor is possible in the unit test.

More information about the usage of Mockito can be found in their https://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/Mockito.html[reference documentation].

== Verify Behaviour with Assertions

Assertions are expressed through the https://assertj.github.io/doc/[AssertJ] assertion library.

The AssertJ DSL provides a fluent API to perform validations on results of the classes under test. The assertion methods (like `assertThat`) should be statically imported from:

[source,java,indent=0]
----
include::example$/ex1/src/test/java/testing/ex1/assertj/AssertJAssertionExampleTest.java[tags=unit-test-assertj-assertion-example-import]
----

Here is a simple example of an AssertJ assertion for a String.

[source,java,indent=0]
----
include::example$/ex1/src/test/java/testing/ex1/assertj/AssertJAssertionExampleTest.java[tags=unit-test-assertj-assertion-example-string-assertion]
----

Note that it is possible to chain multiple assertions that belong to the same result object.

In case of a failing test, JUnit / AssertJ will provide a proper error message about the difference between the expectation and the actual behaviour:

```
Expecting actual:
  "Mike Myers"
to end with:
  "Murphy"
```

Depending on the type of the object, AssertJ provides different assertion methods to compare values. When comparing lists, AssertJ provides corresponding assertion methods like `hasSize` or `contains`:


[source,java,indent=0]
----
include::example$/ex1/src/test/java/testing/ex1/assertj/AssertJAssertionExampleTest.java[tags=unit-test-assertj-assertion-example-list-assertion]
----

For more information about those assertions, you can read the https://assertj.github.io/doc/[AssertJ documentation].
