= 使用数据组件

在本章节将展示使用数据组件的实战例子。

[[declarative-usage]]
== 声明式用法

通常，数据组件都是在视图 XML 描述中声明式地定义并绑定至可视化组件。如果使用 Studio 为实体创建视图，可以看到 XML 中的 `<data>` 元素，包含数据组件的声明。

下面是 `User` 实体详情视图中的数据组件示例，`User` 与 `Department` 实体有 to-one 的关联，和 `UserStep` 实体有 to-many 关联：

[source,xml,indent=0]
----
include::example$/onboarding/src/main/resources/com/company/onboarding/view/user/user-detail-view-2.xml[tags=data]
----
<1> `data` 根元素定义 xref:data/data-context.adoc[DataContext] 实例。
<2> `User` 实体的 `InstanceContainer`。
<3> 可选的 xref:data-access:fetching.adoc#fetch-plan[fetchPlan] 属性，定义从数据库预加载的对象关系图。
<4> `InstanceLoader`，加载 `User` 实例。
<5> 内部 `UserStep` 实体的 `CollectionPropertyContainer`。绑定至 `User.steps` 集合属性。
<6> `Department` 实体的 `CollectionContainer`。可以用于选择部门的下拉框选项列表。
<7> `CollectionLoader` 用指定的查询语句加载 `Department` 实体实例。

上面数据容器可以在可视化组件中这样使用：

[source,xml,indent=0]
----
include::example$/onboarding/src/main/resources/com/company/onboarding/view/user/user-detail-view-2.xml[tags=components]
----
<1> 单独的控件具有 `dataContainer` 和 `property` 属性。
<2> `formLayout` 组件会将 `dataContainer` 传递给表单内部的字段，所以字段只需要 `property` 属性。
<3> `entityComboBox` 也有 `itemsContainer` 属性，获取选项列表。
<4> `dataGrid` 只有 `dataContainer` 属性。

[[programmatic-usage]]
== 编程式用法

可以使用编程的方式在可视化组件中创建和使用数据组件。

下面的例子中，我们创建了跟上一节一样的编辑视图，使用了相同的数据和可视化组件，只不过是用纯 Java 实现的。

[source,java,indent=0]
----
include::example$/onboarding/src/main/java/com/company/onboarding/view/user/UserDetailViewProgrammatic.java[tags=progr]
----
<1> `DataComponents` 是创建数据组件的工厂。
<2> `DataContext` 实例在视图注册，以便能使用标准的提交操作。
<3> `userDl` 加载器会加载数据到 `userDc` 容器。
<4> `userDl` 加载器会合并加载的实体到数据上下文以便跟踪改动。
<5> `stepsDc` 创建为属性容器。
<6> 给 `departmentsDl` 加载器指定了一个查询语句。
<7> `ContainerValueSource` 用来绑定单一字段和容器。
<8> `CollectionContainer` 用来为查找控件提供选项。
<9> `ContainerDataGridItems` 用来绑定表格到容器。
<10> `getEditedEntityContainer()` 被重写了，用来指定容器，替代了 `@EditedEntityContainer` 注解。
<11> 在视图展示前加载数据。框架会自动设置编辑实体的 id 到 `userDl`。

[[dependencies-between-data-components]]
== 数据组件依赖

有时候需要加载和展示依赖同一视图上其他数据的数据。例如，在下面的图片中，左边的表格展示用户列表（`User` 实体），右边的表格展示选中用户的入职步骤（`UserStep` 实体）。右边的列表会在左边列表每次变更选择时刷新。

image::data/dependent-tables.png[align="center"]

这个例子中，`User` 实体包含了 `steps` 属性，这个是一对多的集合。所以实现这个视图的最简单的方法就是使用带有 `steps` 属性的 xref:data-access:fetching.adoc#fetch-plan[fetch plan] 加载用户列表，并且使用 xref:flow-ui:data/property-containers.adoc[属性容器] 来保存 `UserStep` 列表。然后绑定左边的表格到主容器，绑定右边的表格到属性容器。

但是这个方案有一个隐藏的性能问题：会加载左边表格所有用户的所有 `UserStep` 实体，尽管每次只是展示单一用户的 `UserStep`。这就是为什么我们推荐只在加载单一主实体的时候使用属性容器和深度 fetch plan 处理集合属性，例如，在用户的详情视图中。

还有，主实体也许跟依赖的实体没有直接的属性关联关系。这种情况下，上面使用属性容器的方案根本就行不通。

组织视图内数据关系的通常方法是使用带参数的查询。依赖的加载器包含一个带参数的查询语句，这个参数关联到主实体的数据，当主容器的当前实体更改时，需要手动设置参数并且触发依赖的加载器。

下面这个例子的视图包含两对相互依赖的容器/加载器以及绑定的表格。

[source,xml,indent=0]
----
include::example$/onboarding/src/main/resources/com/company/onboarding/view/user/user-with-steps-list-view.xml[tags=depend]
----
<1> 主容器和主加载器。
<2> 依赖容器和加载器。
<3> 由于没有使用 xref:flow-ui:facets/dataLoadCoordinator.adoc[DataLoadCoordinator] facet，我们会在控制器中以编程的方式触发加载器。
<4> 主表格。
<5> 从表格。

[source,java,indent=0]
----
include::example$/onboarding/src/main/java/com/company/onboarding/view/user/UserWithStepsListView.java[tags=depend]
----
<1> 主数据加载器在 `BeforeShowEvent` 处理器中触发。
<2> 在主数据容器的 `ItemChangeEvent` 处理器中，为依赖的加载器设置参数并触发加载。

TIP: 使用 xref:flow-ui:facets/dataLoadCoordinator.adoc[DataLoadCoordinator] facet 可以将数据组件通过声明式的方式连接，不需要写 Java 代码。

// [[using-view-parameters-in-loaders]]
// == Using Screen Parameters in Loaders
//
// It is often required to load data in a view depending on parameters passed to that view. Below is an example of a browse view that accepts a parameter and uses it to filter the loaded data.
//
// Suppose we have two entities: `Country` and `City`. The `City` entity has the `country` attribute that is a reference to `Country`. The cities browser accepts a country instance and shows cities only of this country.
//
// First, consider the cities view XML descriptor. Its loader contains a query with a parameter:
//
// [source,xml,indent=0]
// ----
// include::example$/ex1/src/main/resources/ui/ex1/screen/data/city-browse.xml[tags=loader]
// ----
//
// The cities view controller contains a public setter for the parameter and uses this parameter in the `BeforeShowEvent` handler.
//
// [source,java,indent=0]
// ----
// include::example$/ex1/src/main/java/ui/ex1/screen/data/CityBrowse.java[tags=controller]
// ----
//
// The cities view can be opened from another view passing a country as follows:
//
// [source,java,indent=0]
// ----
// include::example$/ex1/src/main/java/ui/ex1/screen/data/ShowCities.java[tags=show]
// ----

[[custom-sorting]]
== 自定义排序

UI 表格中按照实体属性排序的功能是通过 `CollectionContainerSorter` 实现的，这个排序器需要设置给 xref:flow-ui:data/collection-container.adoc[CollectionContainer]。标准的实现是，如果数据在一页以内能显示，则在内存做数据排序，否则会使用适当的 "order by" 语句发送一个新的数据库请求。"order by" 语句是由 `JpqlSortExpressionProvider` bean 创建。

有些实体属性需要一个特殊的排序实现。下面我们用个例子解释一下如何自定义排序：假设有 `Department` 实体带有 `String` 类型的 `num` 属性，但是我们知道该属性其实是只保存数字。所以我们希望排序的顺序是 `1, 2, 3, 10, 11`。但是，默认的排序行为会产生这样的结果：`1, 10, 11, 2, 3`。

首先，创建一个 `CollectionContainerSorter` 类的子类，在内存进行排序：

[source,java,indent=0]
----
include::example$/onboarding/src/main/java/com/company/onboarding/app/CustomCollectionContainerSorter.java[]
----

在视图中创建排序器：

[source,java,indent=0]
----
include::example$/onboarding/src/main/java/com/company/onboarding/view/department/DepartmentListView2.java[tags=custom-sort]
----

如果排序器定义了一些全局的行为，则可以创建自定义的工厂在系统级别实例化该排序器：

[source,java,indent=0]
----
include::example$/onboarding/src/main/java/com/company/onboarding/app/CustomSorterFactory.java[]
----

最后，为数据库级别的排序创建我们自己定义的 `JpqlSortExpressionProvider` 实现：

[source,java,indent=0]
----
include::example$/onboarding/src/main/java/com/company/onboarding/app/CustomSortExpressionProvider.java[]
----
