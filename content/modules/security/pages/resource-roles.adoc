= Ресурсные роли

Ресурсные роли предоставляют пользователям разрешения на определенные объекты и действия в системе: операции CRUD с сущностями, атрибутами сущностей, экранами UI и так далее.

NOTE: Пользователь без ресурсных ролей не имеет разрешений и не может получить доступ к данным и пользовательскому интерфейсу приложения.

[[create]]
== Создание ресурсных ролей

Создавать ресурсные роли можно во время разработки с помощью аннотированных интерфейсов Java или во время выполнения с помощью экранов UI, доступных в разделе *Administration -> Resource roles*.

Роль должная иметь удобное для пользователя имя и код. Код используется при назначении роли, поэтому не изменяйте его, если эта роль уже назначена некоторым пользователям.

Пример определения роли во время разработки:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/security/ex1/security/FullAccessRole.java[tags=role-1;role-2]
----
<1> Аннотация `@ResourceRole` указывает, что интерфейс определяет ресурсную роль.
<2> Удобное для пользователя имя роли.
<3> Код роли.
<4> Интерфейс может иметь один или несколько методов для определения аннотаций политики (см. ниже). Различные методы используются только для группировки связанных политик. Имена методов могут быть произвольными, они отображаются как *Policy group*, когда роль показывается в UI.

[[policies]]
== Ресурсные политики

Ресурсные роли определяют разрешения, задавая _ресурсные политики_. Политика объединяет ресурс с разрешенным типом доступа к нему.

[[entity-policy]]
=== Политика сущностей

Политика сущностей определяет, какие операции CRUD разрешены для сущности.

В роли, определенной во время разработки, политика сущностей определяется аннотацией `@EntityPolicy`, например:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/security/ex1/security/permissions/CustomerNonConfidentialAccessRole.java[tags=entity-policy;method]
----

Параметр `entityClass` указывает сущность. Чтобы определить политику для всех сущностей, используйте параметр `entityName` со значением `*`.

Параметр `actions` указывает разрешенные операции CRUD. Чтобы разрешить все операции, используйте значение `EntityPolicyAction.ALL`.

[[entity-attribute-policy]]
=== Политика атрибутов сущностей

Политика атрибутов сущностей определяет, какие атрибуты сущностей разрешены.

В роли, определенной во время разработки, политика атрибутов сущностей определяется аннотацией `@EntityAttributePolicy`, например:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/security/ex1/security/permissions/CustomerNonConfidentialAccessRole.java[tags=entity-attribute-policy;method]
----

Параметр `entityClass` указывает сущность. Чтобы определить политику для всех сущностей, используйте параметр `entityName` со значением `*`.

Параметр `attributes` указывает имена атрибутов сущности. Чтобы определить политику для всех атрибутов сущности, используйте значение `*`.

Параметр `action` указывает разрешенный уровень доступа: `VIEW` (просмотр) или `MODIFY` (модификация). Право на модификацию автоматически предоставляет доступ к просмотру.

[[screen-policy]]
=== Политика экранов

Политика экранов определяет разрешенные экраны UI.

В роли, определенной во время разработки, политика экранов определяется аннотацией `@ScreenPolicy`, например:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/security/ex1/security/permissions/CustomerNonConfidentialAccessRole.java[tags=screen-policy;method]
----

Параметр `screenIds` задает идентификаторы разрешенных экранов UI. Чтобы разрешить все экраны, используйте значение `*`.

[[menu-policy]]
=== Политика меню

Политика меню определяет разрешенные пункты главного меню Backoffice UI.

В роли, определенной во время разработки, политика меню определяется аннотацией `@MenuPolicy`, например:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/security/ex1/security/permissions/CustomerNonConfidentialAccessRole.java[tags=menu-policy;method]
----

Параметр `menuIds` задает идентификаторы разрешенных пунктов меню. Чтобы разрешить все пункты меню, используйте значение `*`.

[[specific-policy]]
=== Специальная политика

Специальная политика определяет разрешения для произвольных именованных функций.

Фреймворк использует специальные разрешения для ограничения доступа к различным механизмам. Например, xref:rest:index.adoc[Generic REST API] определяет политику `rest.enabled`, поэтому пользователь должен иметь это разрешение, чтобы иметь возможность взаимодействовать с приложением через интерфейс Generic REST.

Также можно использовать специальные политики для ограничения доступа к функциям приложения. Ниже приведен пример такого контроля доступа.

В роли, определенной во время разработки, специальная политика определяется аннотацией `@SpecificPolicy`, например:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/security/ex1/security/permissions/CustomerFullAccessRole.java[tags=specific-permission]
----

Политика проверяется в коде приложения классами `AccessManager` и `SpecificOperationAccessContext`, предоставляемыми фреймворком:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/security/ex1/service/NotificationService.java[tags=specific-permission]
----

Узнать больше о проверке разрешений можно в разделе xref:security:authorization.adoc#access-constraints[Ограничения доступа].

Чтобы разрешить все существующие специальные политики, используйте значение `*` в аннотации `@SpecificPolicy.resources`.

== Детализация ролей

Ресурсная роль может иметь любое количество политик, а пользователь может иметь любое количество ролей. Следовательно, можно создавать роли с различными уровнями детализации:

* Детализированные роли определяют разрешения для тесно связанных ресурсов, таких как сущность, ее экраны UI и пункты меню. Например, "Полный доступ к Клиентам", "Может создавать и обновлять Заказы". Обычно пользователю назначается несколько таких ролей.

* Крупномасштабные роли определяют все разрешения, необходимые для конкретной задачи, например "Продавец". Такая роль может сама определять все разрешения или наследовать их от дочерних ролей, поэтому крупномасштабная роль может быть создана как совокупность детализированных ролей.

Рекомендуется создавать детализированные роли во время разработки и использовать UI приложения только для их объединения в различные крупномасштабные роли для простого назначения пользователям и для редких специальных изменений в модели безопасности.

[[example]]
== Пример

Ниже приведен полный пример ресурсной роли, определенной во время разработки, которая обеспечивает ограниченный доступ к следующим сущностям и их экранам UI:

[plantuml]
....
@startuml

class Customer {
    name : String
    region : String
    details : List<CustomerDetail>
    confidentialInfo : String
}

class CustomerDetail {
    customer : Customer
    content : String
    confidential : Boolean
}

Customer "1" *- "0..*" CustomerDetail : \t

@enduml
....

[source,java,indent=0]
----
include::example$/ex1/src/main/java/security/ex1/security/permissions/CustomerNonConfidentialAccessRole.java[tags=role]
----
