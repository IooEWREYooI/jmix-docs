= Роли уровня строк

Роли уровня строк _(row-level roles)_ позволяют ограничить доступ к определенным строкам данных или, другими словами, к экземплярам сущностей.

NOTE: Пользователь без ролей уровня строк имеет доступ ко всем экземплярам сущностей, разрешенным xref:resource-roles.adoc[ресурсными ролями].

[[create]]
== Создание ролей уровня строк

Создавать роли уровня строк можно во время разработки с помощью аннотированных интерфейсов Java или во время выполнения с помощью экранов UI, доступных в разделе *Administration -> Row-level roles*.

Роль должная иметь удобное для пользователя имя и код. Код используется при назначении роли, поэтому не изменяйте его, если эта роль уже назначена некоторым пользователям.

Пример определения роли во время разработки:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/security/ex1/security/restrictions/LimitedAmountOrdersRole.java[tags=role-1;role-2]
----
<1> Аннотация `@RowLevelRole` указывает, что интерфейс определяет роль уровня строк.
<2> Удобное для пользователя имя роли.
<3> Код роли.
<4> Интерфейс может иметь один или несколько методов для определения аннотаций политики (см. ниже). Различные методы используются только для группировки связанных политик. Имена методов могут быть произвольными, они отображаются как *Policy group*, когда роль показывается в UI.


[[policies]]
== Политики уровня строк

Роли уровня строк определяют ограничения, задавая _политики уровня строк_ для определенных сущностей.

[[jpql-policy]]
=== JPQL-политика

JPQL-политика указывает выражение `where` (и опционально `join`), которое будет использоваться при загрузке сущности.

JPQL-политика преобразует оператор JPQL (и, следовательно, SQL) и отфильтровывает запрещенные экземпляры на уровне базы данных, что очень эффективно с точки зрения производительности. Но нужно иметь в виду, что это влияет только на корневую сущность загруженного графа объектов. Если сущность может быть загружена как коллекция в графе объектов другой сущности, нужно определить для нее как JPQL-, так и <<predicate-policy,предикатные>> политики.

В роли, определенной во время разработки, JPQL-политика определяется аннотацией `@JpqlRowLevelPolicy`, например:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/security/ex1/security/restrictions/CreatedByMeOrdersRole.java[tags=role]
----

При написании JPQL-политик учитывайте следующие правила:

* Используйте плейсхолдер `\{E\}` вместо алиаса сущности в выражениях `where` и `join`. Фреймворк заменит его реальным алиасом, указанным в запросе.

* Содержимое `where` добавляется в выражение `where` запроса с использованием условия `and`. Добавление самого слова `where` не требуется, так как оно будет добавлено автоматически.

* Содержимое `join` добавляется в выражение `from` запроса. Оно должно начинаться с запятой или слов `join` или `left join`.

Можно использовать параметры xref:data-access:jpql-extensions.adoc#session-and-user-attributes[атрибутов сессии и пользователя]. Например, параметр `current_user_username` получает свое значение из атрибута `username`.

Также можно добавить атрибуты, относящиеся к конкретному приложению, в сущность `User` и использовать их в JPQL-политиках. Например, представим, что к сущностям `User` и `Customer` был добавлен атрибут `region`. Затем можно ограничить доступ к объектам `Customer` и `Order`, разрешив пользователям видеть только сущности своего региона:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/security/ex1/security/restrictions/SameRegionRowsRole.java[tags=role]
----

[[predicate-policy]]
=== Предикатная политика

Предикатная политика определяет предикат, который проверяется при выполнении различных действий с сущностью. Если предикат возвращает значение true, данное действие разрешено для данного экземпляра сущности.

Предикатные политики можно определить для следующих действий: `READ`, `CREATE`, `UPDATE`, `DELETE`.

Предикат `READ` проверяется при загрузке сущности из базы данных для корневой сущности и (в отличие от <<jpql-policy,JPQL-политики>>) всех вложенных коллекций вплоть до графа загруженных объектов. Если сущность может быть загружена как коллекция в графе объектов другой сущности, нужно определить для нее как JPQL-, так и <<predicate-policy,предикатные>> политики.

Предикаты `CREATE`, `UPDATE`, `DELETE` проверяются перед созданием, обновлением или удалением экземпляра сущности из базы данных.

В роли, определенной во время разработки, предикатная политика определяется аннотацией `@PredicateRowLevelPolicy`, например:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/security/ex1/security/restrictions/NonConfidentialRowsRole.java[tags=role]
----

В этом примере показана роль уровня строки, которую следует использовать в дополнение к ресурсным ролям из примера в xref:resource-roles.adoc#example[предыдущем разделе] для ограничения доступа к экземплярам `CustomerDetail`, имеющим атрибут `confidential = true`. JPQL-политику нельзя использовать для фильтрации экземпляров `CustomerDetail` из коллекции `Customer.details`, поскольку она может быть загружена вместе с владельцем `Customer` в рамках одной операции базы данных. Предикатные политики выполняются в памяти и для корневых сущностей, и для вложенных коллекций.

В роли, определенной во время выполнения, предикатная политика  определяется с помощью Groovy-скрипта. Используйте в нем плейсхолдер `\{E\}` в качестве переменной, содержащей экземпляр проверяемой сущности. Например, то же условие, что и в роли, определенной во время разработки выше, может быть записано в виде следующего Groovy-скрипта:

[source,groovy]
----
!{E}.confidential
----

Если в предикате необходим доступ к бинам Spring, возвращайте из метода `io.jmix.security.model.RowLevelBiPredicate`. Этот функциональный интерфейс позволяет создавать лямбду, принимающую два параметра: проверяемый экземпляр сущности и `ApplicationContext` Spring. Например:

[source,java,indent=0]
----
include::example$/ex1/src/main/java/security/ex1/security/restrictions/SameRegionCustomersRole.java[tags=role]
----

В Groovy-скрипте также можно использовать переменную `applicationContext` для доступа к любому бину Spring, например:

[source,groovy]
----
import io.jmix.core.security.CurrentAuthentication

def authBean = applicationContext.getBean(CurrentAuthentication)

{E}.region != null && {E}.region == authBean.user.region
----

