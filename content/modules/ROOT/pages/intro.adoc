= Введение
:page-aliases: quick-start:index.adoc

Добро пожаловать в документацию https://www.jmix.ru[Jmix^]!

[[whats-jmix]]
== Что такое Jmix?

*Jmix* – это высокоуровневый фреймворк для разработки корпоративных веб-приложений. Он предлагает передовой инструментарий и богатый набор функциональных модулей.

Jmix лучше всего подходит для создания ориентированных на данные приложений со сложной моделью данных и насыщенным пользовательским интерфейсом. Это full-stack фреймворк, что означает поддержку разработки и backend, и UI вашего приложения.

Jmix основан на https://spring.io/projects/spring-boot[Spring Boot^], что является фактически стандартом для разработки корпоративных веб-приложений на Java. Это означает, что вы можете использовать множество сторонних библиотек и фреймворков после минимальной конфигурации в дополнение к функционалу самого Jmix.

//Jmix состоит из ряда детализированных модулей, которые можно включить в проект используя стартеры, как в любом приложении Spring Boot. Все модули кроме основного опциональны, таким образом, вы можете использовать только те зависимости, которые вам необходимы.

*Jmix Studio* – это плагин для IntelliJ IDEA, который помогает на всех этапах разработки приложений: создание и конфигурация проекта, определение модели данных, генерация скриптов для миграции базы данных, разработка UI экранов в визуальном редакторе. Он предоставляет продвинутую навигацию, автодополнение кода и инспекции, специфичные для Jmix-проектов.

//[[key-concepts]]
//== Ключевые понятия
//
//Jmix предоставляет удобный способ работы с одной или несколькими реляционными базами данных. Дополнительные усилия позволят вам подключиться к любому источнику данных, такому как база данных NoSQL или внешний API.
//
//Разработка с Jmix обычно начинается с определения xref:data-model:index.adoc[модели данных]. Jmix Studio автоматически создает схему базы данных на ее основе и, когда ваша модель претерпевает изменения, Studio помогает вам синхронизировать базу данных со схемой, генерируя скрипты миграции базы данных. Если у вас уже есть готовая база, с помощью Studio вы можете создать модель данных на основе схемы вашей базы.
//
//Jmix основан на Spring Framework, поэтому вы можете использовать бины Spring для создания бизнес-логики, подходящей для вашей модели данных.
//
//Как только вы добавите сущности в вашу модель данных, Studio сможет генерировать xref:ui:index.adoc[UI] экраны для CRUD операций на сущностях. Затем вы можете разными способами персонализировать UI: изменять макет, добавлять и убирать визуальные компоненты и настраивать загрузку данных.

//[[choosing-ui]]
//=== Choosing UI
//
//You can use any frontend technology to work with Jmix backend through its xref:rest:index.adoc[] or custom endpoints of your application.
//
//Moreover, Jmix provides two specific options for rapid creation of the user interface:
//
//. xref:backoffice-ui:index.adoc[Backoffice UI] allows you to develop the rich web UI using just Java/Kotlin and XML. In this case, your UI components work in the same JVM as your backend, which simplifies working with data and invoking business logic. Also, you don't have to be familiar with the modern JavaScript/HTML/CSS stack.
//+
//The downside of this technology is limited scalability: the backend side of the UI is stateful and consumes the amount of resources proportional to the number of concurrent user sessions. So Backoffice UI is suitable when you have a predictable and not very high (up to tens of thousands) number of users working with the system at the same time.
//
//
//. xref:jmix-frontend-docs:overview:index.adoc[Frontend UI] allows you to create a traditional frontend with React and TypeScript, working with the Java backend through the REST API. It is more flexible in terms of layout customization and enables easy integration of UI libraries and components from the vast JavaScript ecosystem. It's also infinitely scalable, as the UI state resides in the user's browser and the backend is stateless.
//+
//On the other hand, the entry barrier to the Frontend UI is higher if you don't have experience in frontend technologies, and the speed of development is usually lower. This differentiation is amplified by the fact that currently Studio supports Backoffice UI much better than Frontend UI.
//
//Choosing UI is not an "either-or" decision: you can use both technologies in your project. For example, you can quickly create a bunch of administrative screens for internal users of your application with Backoffice UI, and develop a more polished UI with specific functionality for external users using Frontend UI. Both UIs in this case will work with the same data model and business logic.

[[getting-started]]
== Начало работы

//To get started with Jmix, first install Java and Jmix Studio as described in the xref:setup.adoc[Setup] section. After that, check out the https://www.jmix.io/learn/quickstart/studio[Quick Start] video for a 12-minute introduction to building applications with Jmix.

Если вы новичок в Jmix, xref:setup.adoc[настройте] свою среду разработки и посмотрите https://www.jmix.io/learn/quickstart/studio["Быстрый старт"^] - 15-минутное видео для ознакомления с созданием приложений.

После завершения руководства по быстрому старту, изучите https://www.jmix.io/learn/live-demo/[демонстрационные приложения^] и взгляните на https://www.jmix.io/marketplace/[дополнения^], чтобы получить представление о функционале Jmix, предоставляемом "из коробки".

Если вы хотите ознакомиться с основными концепциями Jmix перед тем как погрузиться в разработку, взгляните на архитектурные диаграммы, приведенные ниже.

Используйте данную документацию при разработке на Jmix:

* В разделе xref:studio:index.adoc[Использование Studio] детально представлены особенности Jmix Studio и варианты установки.

* Корневые разделы от xref:data-model:index.adoc[Модели данных] до xref:deployment:index.adoc[Развертывания] объясняют основные функции, помогающие при разработке приложений любого типа.

* Раздел xref:ROOT:add-ons.adoc[Дополнения] описывает дополнительные модули, которые вы можете использовать в своем проекте.

[[architecture]]
== Обзор архитектуры

Here you can find a few diagrams in C4 Model notation that show a birds eye view of the Jmix landscape.

[[architecture-containers]]
=== Контейнеры

First, let's divide a typical information system built with Jmix into containers. A container here is a separately runnable/deployable unit that executes code or stores data.

image::architecture-containers.drawio.svg[align="center"]

As you can see, the main part of the system includes a web application running on JVM and a relational database. The web application is based on Spring Boot and can be written in Java or Kotlin. A relational database is used to store data of Jmix subsystems (for example, security configuration) and as a main storage of application data.

The Jmix application can connect to any number of additional data stores and use a separate file storage on a file system or in the cloud. Also, Jmix offers integrations with Elasticsearch for full-text search through the application data, and with an OIDC server for external authentication and SSO.

The Jmix application provides users with a web interface. It's created in Java/Kotlin and XML using the Jmix UI subsystem.

You can also create a separate frontend application and connect it with the Jmix backend through the Jmix REST API or by creating custom endpoints. Note that frontend applications are out of Jmix scope, you can create them with any technology of your choice.

[[architecture-components]]
=== Компоненты

Let's zoom in to the Jmix Application container and explore its components.

image::architecture-jmix-application.drawio.svg[align="center"]

A Jmix application always contains dependencies to Spring Boot and to a number of Jmix subsystems. There are two categories of Jmix subsystems:

* _Core subsystems_ provide system-level functionality and are included in most projects.

* _Add-ons_ are optional subsystems that can be included in the project on demand. The add-ons are published at Jmix https://www.jmix.io/marketplace/[marketplace^].

Technically, both core subsystems and add-ons are organized in the same way. A subsystem contains one or more functional modules and corresponding Spring Boot starters, each packaged in a JAR file. A subsystem can depend on other subsystems: for example, many add-ons contain screens that require dependency on the core UI subsystem.
