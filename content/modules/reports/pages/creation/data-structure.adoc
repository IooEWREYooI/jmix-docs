[[structure]]
= Структура данных отчета

[[introduction]]
== Определение структуры данных

При создании или редактировании отчета по умолчанию отображается вкладка *Report structure*:

.Структура данных отчета
image::report_structure.png[align="center"]

[[report_properties]]
Общие свойства отчета::
+
--
Верхняя часть содержит поля для ввода общих свойств отчета:

* *Name* – название отчета. Название может быть локализовано на вкладке *Localization*.
* *Group* – группа отчетов. Используется для группировки в стандартном браузере отчетов.
* *Default template* – xref:creation/templates.adoc[шаблон] вывода отчета .
* *System code* – необязательный код, который можно использовать для идентификации отчета в коде приложения.
--

[[report_bands]]
Определение полос отчетов::
+
--
Важным элементом структуры данных отчета является иерархия полос – *Report bands*.

Полоса отчета имеет следующие параметры:

* *Band name* – имя полосы, уникальное в отчете. Оно может содержать только латинские буквы, цифры и символы подчеркивания. Более того, если имя полосы начинается с *header*, ее данные не будут отображены в xref:creation/templates.adoc#table_output[выводе таблицы].
* *Orientation* – ориентация полосы: *Horizontal*, *Vertical* или xref:sample-reports.adoc#crosstab_xls[Crosstab].
** Horizontal – полосы копируются вниз, могут содержать подполосы.
** Vertical – полосы копируются вправо.
** Crosstab – полосы копируются вправо и вниз в виде матрицы.
* *Parent band* – родительская полоса.

Каждая полоса включает в себя один или несколько наборов данных. При запуске отчета наборы данных преобразуются в списки строк, где каждая строка содержит сопоставление пар имя-значение. Полоса появляется в отчете столько раз, сколько строк в ее самом длинном наборе данных.

Имена полей могут быть использованы в шаблоне отчета и будут заменены соответствующими значениями из набора данных при создании отчета. При описании наборов данных вы можете использовать xref:creation/parameter-and-format.adoc#parameters[внешние параметры отчета] и поля из других полос – это позволяет создавать связанные полосы.

Каждый отчет имеет полосу *Root*. В ней можно создавать наборы данных и ссылаться на их поля из других полос, но ее нельзя использовать в шаблоне отчета.

Значение столбца *Dataset name* используется только для удобства пользователя.
--

[[dataset_types]]
== Типы наборов данных

[[structure_sql]]
=== Набор данных SQL

Набор данных *SQL* создается в результате выполнения SQL-запроса. Рекомендуется использовать псевдонимы для полей результатов запроса с использованием оператора `as`. Также рекомендуется заключать псевдонимы в двойные кавычки, чтобы предотвратить возможное преобразование регистра СУБД:

[source, sql,indent=0]
----
select u.name as "userName", u.login as "userLogin" 
from jmxrpr_user u
----

В запросе можно использовать входные параметры отчета и поля родительских полос. К параметрам следует обращаться по имени, заключенному в `${}`, например, `++${dateFrom}++`. К полям родительской полосы следует обращаться аналогично, добавляя название полосы перед именем поля: `${band1.field1}`.

Ниже приведен пример SQL-запроса с параметром `groupId`, полученным из родительской полосы `group`, и внешним параметром `enabled`.:

[source, sql,indent=0]
----
select u.name as "userName", u.login as "userLogin" 
from jmxrpr_user u
where u.group_id = ${group.groupId} 
    and u.enabled = ${enabled}
    and u.delete_ts is null
----

[CAUTION]
====
Вы должны вручную включить условия для фильтрации мягко удаленных записей для SQL-запросов.
====

[[link_field]]
Объединение нескольких наборов данных::
+
--
*Link field* используется для объединения данных из нескольких наборов внутри одного диапазона. Его можно использовать, когда все данные для строки отчета не могут быть получены с помощью одного запроса или скрипта Groovy.
--

[[data_store]]
Выбор хранилища данных::
+
--
По умолчанию запросы выполняются к основной базе данных. Если вы хотите запросить xref:data-model:data-stores.adoc#additional[дополнительное хранилище данных], укажите его имя в поле *Data store*.
--

[[query_preprocessing]]
Предварительная обработка запросов в полосах::
+
--
Если вам нужно динамически изменять запрос SQL/JPQL в зависимости от входных параметров отчета или значений параметров из родительской полосы, вы можете использовать предварительную обработку SQL. Механизм шаблонов позволяет вам изменять запросы SQL/JPQL с помощью Groovy. Чтобы активировать эту возможность, установите флажок *Preprocess query as Groovy template* под редактором полос. Результирующий запрос будет обработан механизмом `GStringTemplateEngine`, который будет иметь доступ к:

* параметрам отчета: `${<parameter_name>}`,

* значениям из родительских полос: `${<band_name>.<parameter_name>}`.

Давайте рассмотрим следующий пример: в зависимости от того, передан ли параметр отчета `createTs2`, вам нужно выбрать одно из условий запроса: `e.create_ts < $\{createTs2\}` или `e.create_ts < current_timestamp`.

В этом случае запрос должен выглядеть следующим образом:

[source, sql,indent=0]
----
select e.create_ts, e.id, e.vin from ref_car e
where
e.create_ts >= ${createTs1}
and
<% out << (createTs2 != null  ? 'e.create_ts < ${createTs2}' : 'e.create_ts < current_timestamp')%>
----

Таким образом, если параметр `createTs2` не передан, исходный запрос будет преобразован в следующий результирующий запрос:

[source, sql,indent=0]
----
select e.create_ts, e.id, e.vin from ref_car e
where
e.create_ts >= ${createTs1}
and
e.create_ts < current_timestamp
----

Если передан `createTs2`, то для полосы будет использоваться следующий результирующий запрос:

[source, sql,indent=0]
----
select e.create_ts, e.id, e.vin from ref_car e
where
e.create_ts >= ${createTs1}
and
e.create_ts < ${createTs2}
----
--

[[structure_jpql]]
=== Набор данных JPQL

Набор данных *JPQL* создается в результате выполнения запроса JPQL. Результирующие поля запроса должны иметь псевдонимы, указанные с помощью оператора `as`. Аналогично SQL-запросу, в запросе JPQL можно использовать входные параметры отчета и поля родительских полос.

Ниже приведен пример запроса JPQL с параметром `groupId`, полученным из родительской полосы `group`, и внешним параметром `enabled`:

[source, jpql,indent=0]
----
select u.name as userName, u.login as userLogin
from jmxrpr_User u
where u.group.id = ${group.groupId}
    and u.enabled = ${enabled}
----

Запросы JPQL автоматически поддерживают мягкое удаление и возвращают только те записи, которые не были удалены.

Вы также можете использовать *Link field* для <<link_field,объединения нескольких наборов данных>>, использовать *Data store* для <<data_store, запроса дополнительного хранилища данных>> или активировать <<query_preprocessing,предварительную обработку запроса>>, установив флажок *Preprocess query as Groovy template* под редактором полос.

[[structure_groovy]]
=== Набор данных Groovy

Набор данных *Groovy* создается в результате выполнения скрипта Groovy. Скрипт возвращает объект типа `List<Map<String, Object>>`. Каждый элемент этого списка – объект типа `Map<String, Object>` – соответствует одной записи набора данных.

В скрипт передаются следующие объекты:

* `params` – отображение внешних параметров отчета. Ниже приведен пример получения значения параметра:
+
[source, groovy,indent=0]
----
def active = params['active']
----

* `parentBand` – родительская полоса как объект типа `com.haulmont.yarg.structure.BandData`. Этот объект позволяет получить значение поля родительской полосы, вызвав метод `getParameterValue()`, например:
+
[source, groovy,indent=0]
----
def groupId = parentBand.getParameterValue('groupId')
----

* `currentAuthentication` - объект типа `io.jmix.core.security.CurrentAuthentication`, связанный с текущим аутентифицированным пользователем. Например:
+
[source, groovy,indent=0]
----
def user = currentAuthentication.getUser()
----

* `metadata` – объект типа `io.jmix.core.Metadata`, предоставляющий доступ к метаданным приложения. Например:
+
[source, groovy,indent=0]
----
def metaClass = metadata.getClass('jmxrpr_User')
----

* `dataManager` – объект типа `io.jmix.core.DataManager`, который обеспечивает функциональность CRUD. Например:
+
[source, groovy,indent=0]
----
def book = dataManager.load(Book).id(bookId).fetchPlan("book.edit").one()
----

* `timeSource` – объект типа `io.jmix.core.TimeSource`, используемый для получения текущего времени. Например:
+
[source, groovy,indent=0]
----
def currentDate = timeSource.currentTimestamp()
----

* `applicationContext` - объект типа `org.springframework.context.ApplicationContext`, который предоставляет доступ к управляемым бинам. Например:
+
[source, groovy,indent=0]
----
def accountService = applicationContext.getBean(AccountService);
----

[[structure_entity]]
=== Набор данных Entity

Набор данных *Entity* состоит из одной строки и создается с использованием атрибутов одного экземпляра сущности JPA и связанных с ним сущностей.

Источник данных создается из внешнего параметра типа *Entity*, который должен быть описан на вкладке *Parameters and Formats*. Значение в поле *Entity parameter name* должно совпадать с именем параметра.

Шаблон отчета должен содержать поля с именами атрибутов сущностей. Имена атрибутов могут использовать имена из существующего фетч-плана, если установлен флажок *Use existing fetch plan*, или могут быть выбраны по нажатию кнопки *Select entity attributes*.

[CAUTION]
====
Поскольку механизм создания отчетов всегда перезагружает объекты в наборе данных *Entity* из БД, его нельзя использовать для сущностей DTO или экземпляров сущностей JPA, не сохраненных в базе данных. Вместо него используйте <<structure_groovy,набор данных Groovy>> и обращайтесь к сущности, переданной в качестве параметра следующим образом:

[source,groovy,indent=0]
----
def entity = params['entity']

return [['title': entity.title,
        'description': entity.description]]
----
====

[[structure_list]]
=== Набор данных List of Entities

Набор данных *List of entities* создается с использованием списка экземпляров сущностей JPA.

Источник данных создается с использованием внешнего параметра, представляющего собой *List of entities*, который должен быть описан на вкладке *Parameters and Formats*. Значение в поле *Entity parameter name* должно соответствовать псевдониму параметра.

Шаблон отчета должен содержать поля с именами атрибутов сущностей. Имена атрибутов могут использовать имена из существующего фетч-плана, если установлен флажок *Use existing fetch plan*, или могут быть выбраны по нажатию кнопки *Select entity attributes*.

[CAUTION]
====
Поскольку механизм создания отчетов всегда перезагружает объекты в наборе данных *List of entities* из БД, его нельзя использовать для сущностей DTO или экземпляров сущностей JPA, не сохраненных в базе данных. Вместо него используйте <<structure_groovy,набор данных Groovy>> и обращайтесь к сущности, переданной в качестве параметра следующим образом:

[source,groovy,indent=0]
----
return params['entities'].collect {[
    'title': it.title,
    'description': it.description
]}
----
====

[[structure_json]]
=== Набор данных JSON

Набор данных *JSON* генерируется на основе данных JSON. Эти данные могут быть получены из следующих источников:

. *Groovy script*
+
--
Скрипт, предоставленный пользователем, должен возвращать данные JSON в виде строки.

Например:

[source, json,indent=0]
----
include::example$/ex2/src/main/resources/reports/ex2/docrefs/json.groovy[]
----
--

. *URL*
+
--
Механизм создания отчетов выполнит HTTP-запрос GET по URL-адресу.

Например:

[source, plain,indent=0]
----
https://jsonplaceholder.typicode.com/users
----
--

. *Parameter of a String type*
+
--
Внешний параметр отчета строкового типа, содержащий данные JSON, должен быть описан на вкладке *Parameters and Formats*.
--

Полученное дерево JSON запрашивается с помощью запроса JSONPath. Например, вы можете использовать JSONPath `$.store.book[*]`, чтобы вернуть все книги из следующего дерева JSON:

[source, json,indent=0]
----
include::example$/ex2/src/main/resources/reports/ex2/docrefs/json.json[]
----

Для получения более подробной информации о выражениях JSONPath обратитесь к the http://goessner.net/articles/JsonPath/[документации JSONPath^].

[CAUTION]
====
Выводимые отчетом поля, которые имеют типы данных `Date`, `DateTime` или `Time`, не поддерживают формат, определенный `java.text.SimpleDateFormat``. Чтобы установить правильный формат, следует написать скрипт Groovy.

Для этого перейдите на вкладку **Parameters and Formats** редактора отчетов и откройте редактор xref:creation/parameter-and-format.adoc#formatters[formatter]. Например, в случае поля `bookPublication.dateTime` Groovy-скрипт будет выглядеть следующим образом:

[source, groovy,indent=0]
----
include::example$/ex2/src/main/resources/reports/ex2/docrefs/formatter_for_dates.groovy[]
----
====

