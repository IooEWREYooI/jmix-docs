= Помощь при написании кода

Jmix Studio предоставляет автодополнение и инспекцию кода, выделение ошибок и быстрое исправление, а также удобный рефакторинг кода и широкие возможности навигации.

Давайте рассмотрим, как выглядят основные инструменты для помощи при написании кода.

[[code-inspection]]
== Инспекция кода

Jmix Studio автоматически обнаруживает и предлагает исправить типичные ошибки программирования в проекте перед его компиляцией.

В зависимости от уровня критичности Studio по-разному выделяет код, содержащий проблему.

image::code-inspections2.png[align="center"]

image::code-inspections1.png[align="center"]

Для некоторых инспекций Jmix Studio предлагает использовать <<quick-fixes,быстрые исправления>>.

[[quick-fixes]]
== Быстрые исправления

Если при инспекции в коде обнаружена ошибка, в редакторе можно быстро внести исправление. Наведите курсор на выделенный фрагмент кода и нажмите `Alt+Enter`.

image::red-bulb.gif[align="center"]

Другой способ — наведите курсор на выделенный фрагмент кода и щелкните значок image:intentionBulb.png[yellow-bulb]/image:quickfixBulb.png[red-bulb]. После этого вы сможете просмотреть доступные intention-действия.

image::yellow-light.gif[align="center"]

[[line-markers]]
== Маркеры строк

Маркер строки — это значок на полосе слева окна редактора. Например, маркеры строк могут служить точками навигации для связанного кода:

image::line-markers.gif[align="center"]

Используя маркер строки, можно редактировать фетч-план в дескрипторе XML:

image::line-markers-fetch-plan.gif[align="center"]

[[navigation]]
== Навигация

Например, вы можете перейти к внедренному компоненту или локализованному сообщению в пакете сообщений. Удерживая `Ctrl`, щелкните левой кнопкой мыши по id компонента или ключу сообщения.

image::references.gif[align="center"]

[[refactorings]]
== Рефакторинг

Вы можете легко и безопасно вносить изменения. В приведенном ниже примере мы изменим имя кнопки.

image::refactorings.gif[align="center"]

Используя рефакторинг, вы можете переименовывать или удалять перечисления и классы сущностей, компоненты и экраны.

////
== Live Templates

To apply a live template, type a template abbreviation, and press `Tab` in the completion list to expand the template. After that, use `Enter` or `Tab` to navigate through template parameters.

Jmix Studio has the *field* live template. Use it in the XMl descriptor to create a field in `form`. This live template automatically substitutes the type of the entity attribute:

image::live-template.gif[align="center"]
////

////
== Postfix Templates

Postfix template is a template, which can be invoked in Java through the auto-completion menu after a dot. After the invocation it wraps the code under a cursor into some expression according to the template:

image::postfix-template.gif[align="center"]

These templates also add the required injection of Jmix resource, if needed (like `DataManager` in the example above).

You can use such postfix templates in Jmix Studio:

* `someJmixEntity.save` -> `dataManager.save(someJmixEntity)`.
* `fileRef.open` -> `fileStorage.openStream(fileRef)`
+
where `fileRef` is an instance of `io.jmix.core.FileRef`.
* `event.publish` -> `uiEventPublisher.publishEvent(event)`
+
where `event` is an instance of `org.springframework.context.ApplicationEvent`.
////

== Область применения помощи при написании кода

Рассмотрим основные части проекта и различные случаи использования инструмента помощи при написании кода.

* *Перечисления и сущности*

Инспекции::
** xref:data-model:entities.adoc[Сущность] с таким же именем таблицы уникальна в xref:data-model:data-stores.adoc[хранилище данных].
** Проверка наличия аннотации xref:data-model:entities.adoc#instance-name[@InstanceName].
** Обнаружение некорректного использования фетч-типа `LAZY` для полей datatype и `@OneToOne`, `@OneToMany`, `@ManyToMany` и `@ManyToOne` с фетч-типом `EAGER`.
** Проверка наличия аннотаций JPA для каждого поля сущности.
** Проверка того, что классы и атрибуты сущностей и перечислений имеют локализованные сообщения.
** Проверка того, что атрибуты персистентного перечисления объявлены в соответствии с правилами Jmix — с использованием типа идентификатора.
** Проверка наличия дубликатов аннотации `@Version`.
** Проверка наличия встраиваемых атрибутов, не отмеченных аннотацией `@Embedded`.
** Проверка наличия атрибута первичного ключа сущности.

Быстрые исправления и intention-действия::

** Генерация имени экземпляра.
** Добавление атрибута сущности с помощью дизайнера.
** Добавление атрибута сущности в таблицы, формы и сетки.
** Изменение разрешений атрибутов сущности для различных ресурсных ролей.
** Изменение разрешений сущности для разных ресурсных ролей.

* *XML-дескрипторы*

Инспекции::

** Проверка имен свойств и путей в компонентах `table`, `form`, и других компонентах.
** Проверка атрибутов `dataContainerи` и `optionsContainer`.
Они должны ссылаться на существующий контейнер данных в текущем окне или на одно из окон, которое включает текущее в качестве фрейма.
** Проверка колонок в строке с указанным количеством колонок в `gridLayout`.
** Проверка следующих аспектов дескрипторов окон Jmix:

*** Атрибут `expand`;
*** Уникальность `id`.

** Проверка того, что атрибут `trackSelection` не задан для действия с атрибутом `type`.
** Сообщение о случаях, когда атрибут сущности используется компонентом UI в XML-дескрипторе, но не включен в фетч-план.
** Проверка ошибок, когда в компоновке XML имеется более одного корневого компонента.
** Поиск конфликтующих значений атрибутов `width`, `height`, и `expand` в XML-дескрипторе.
** Проверка следующих аспектов `form`:

*** Дублирующиеся поля.
*** Поля из `column`.

** Проверка атрибута `hierarchyProperty`. Он должен быть того же типа, что и сущность в контейнере данных.

* *Фетч-планы*

** Проверка того, что для `fetchPlan` установлен атрибут `class` .
** Поиск свойств, объявленных дважды внутри одного и того же тега `fetchPlan`.
** Проверка, существует ли фетч-план с текущим именем в конфигурации другого фетч-плана.
** Проверка, содержит ли свойство `fetchPlan` внутренние свойства или атрибут `fetchPlan`. Тогда свойство должно указывать на сущность.
** Поиск ненужных свойств, которые можно опустить, поскольку они уже включены в фетч-план.

* *Контроллеры*

Инспекции::

** Проверка, ссылается ли на каждый сеттер только один установленный метод.
** Инспекция компонентов, действий и компонентов данных, которые инжектируются в контроллер экрана. Сообщение, если инжектированные поля имеют неправильный тип.

** Инспекция компонентов, инжектированных в контроллер экрана. Сообщение, если инжектированное поле не имеет стандартного типа, например, `Table` вместо `Table<MyEntity>`. Обеспечивает быстрое исправление.
** Проверка, правильно ли реализован слушатель событий. Возможные сообщения:

*** Слушатель событий должен располагаться только внутри контроллера экрана.
*** Слушатель событий должен иметь возвращаемый тип `void`.
*** Слушатель событий должен иметь один аргумент с типом, расширяющим `java.util.EventObject`.
*** Не удалось найти указанный компонент UI.

** Проверка установленных делегатов. Возможные сообщения:

*** Делегат может быть установлен только внутри контроллера экрана.
*** Не удалось найти точку установки для делегата.
*** Точка установки должна быть методом с возвращаемым типом `void` и одним параметром типа `FunctionalInterface`.
*** Не удалось найти указанный компонент UI.

** Подсветка подозрительных назначений полям, которые, возможно, инжектируются контейнером.
** Проверка, что компоненты GUI созданы с использованием `ComponentsFactory.createComponent()`.

Быстрые исправления и intention-действия::

** Изменения разрешений экрана для разных ресурсных ролей.
** Создание XML-дескриптора для контроллера экрана.
** Переход к пункту меню из контроллера.

* *Логирование*

Инспекции::

** Проверка, используется ли логгер `org.slf4j.Logger` вместо
`System.out.println()`, `System.err.println()` и `java.lang.ThrowableprintStackTrace()`.
** Подсветка выражений логирования, при которых теряется stack trace исключения.

* *Меню*

Инспекции::

** Проверка, нет ли в меню повторяющихся элементов.

* *Безопасность*

Инспекции::

** Проверка повторяющихся полей кода в ресурсных ролях.
** Проверка повторяющегося поля имени в ресурсных ролях.
** Проверка наличия экрана в проекте.
** Проверка политики атрибутов сущности в ресурсных ролях.

* *Бины и службы*

Инспекции::

** Проверка того, что бин службы является правильным компонентом фреймворка Jmix.





